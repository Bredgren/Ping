// Generated by CoffeeScript 1.6.2
(function() {
  var CircleBall, Game, H, Paddle, W, log_input, main, settings,
    __slice = [].slice;

  CircleBall = (function() {
    function CircleBall() {}

    return CircleBall;

  })();

  settings = {
    DEBUG: true,
    PRINT_INPUT: false,
    WIDTH: 1000,
    HEIGHT: 500,
    PPM: 30,
    BOX2D_TIME_STEP: 1 / 60,
    BOX2D_VI: 10,
    BOX2D_PI: 10,
    BINDINGS: {
      P1_UP: 87,
      P1_DOWN: 83,
      P1_LEFT: 65,
      P1_RIGHT: 68,
      P2_UP: 38,
      P2_DOWN: 40,
      P2_LEFT: 37,
      P2_RIGHT: 39,
      START: 32
    }
  };

  Game = (function() {
    Game.prototype.states = {
      MENU: 0,
      GAME: 1,
      END: 2
    };

    Game.prototype.state = null;

    function Game(stage) {
      var cx, cy, style;

      this.stage = stage;
      this.hud_stage = new PIXI.DisplayObjectContainer();
      this.game_stage = new PIXI.DisplayObjectContainer();
      this.bg_stage = new PIXI.DisplayObjectContainer();
      this.stage.addChild(this.bg_stage);
      this.stage.addChild(this.game_stage);
      this.stage.addChild(this.hud_stage);
      this.hud_graphics = new PIXI.Graphics();
      this.hud_stage.addChild(this.hud_graphics);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.instruction_text = new PIXI.Text("", style);
      cx = settings.WIDTH / 2;
      cy = settings.HEIGHT / 2;
      this.instruction_text.anchor.x = 0.53;
      this.instruction_text.anchor.y = 0.53;
      this.instruction_text.position.x = cx;
      this.instruction_text.position.y = cy;
      this.gotoMenu();
    }

    Game.prototype.update = function() {};

    Game.prototype.clear = function() {
      return this.hud_graphics.clear();
    };

    Game.prototype.draw = function() {};

    Game.prototype.startGame = function() {
      this.state = this.states.GAME;
      return this.hud_stage.removeChild(this.instruction_text);
    };

    Game.prototype.endGame = function() {
      this.state = this.states.END;
      console.log(this.state);
      this._setInstructionText("Press SPACE to return to menu");
      return this.hud_stage.addChild(this.instruction_text);
    };

    Game.prototype.gotoMenu = function() {
      this.state = this.states.MENU;
      this._setInstructionText("Press SPACE to begin");
      return this.hud_stage.addChild(this.instruction_text);
    };

    Game.prototype._setInstructionText = function(text) {
      return this.instruction_text.setText(text);
    };

    Game.prototype.onKeyDown = function(key_code) {
      var bindings;

      bindings = settings.BINDINGS;
      switch (key_code) {
        case bindings.P1_UP:
          return console.log('up1');
        case bindings.P1_DOWN:
          return console.log('down1');
        case bindings.P1_LEFT:
          return console.log('left1');
        case bindings.P1_RIGHT:
          return console.log('right1');
        case bindings.P2_UP:
          return console.log('up2');
        case bindings.P2_DOWN:
          return console.log('down2');
        case bindings.P2_LEFT:
          return console.log('left2');
        case bindings.P2_RIGHT:
          return console.log('right2');
        case bindings.START:
          switch (this.state) {
            case this.states.MENU:
              return this.startGame();
            case this.states.END:
              return this.gotoMenu();
            case this.states.GAME:
              return this.endGame();
          }
      }
    };

    Game.prototype.onKeyUp = function(key_code) {};

    Game.prototype.onMouseDown = function(button, screen_pos) {};

    Game.prototype.onMouseUp = function(button, screen_pos) {};

    Game.prototype.onMouseMove = function(screen_pos) {};

    Game.prototype.onMouseWheel = function(delta) {};

    return Game;

  })();

  $(function() {
    var DOM_LOADED;

    DOM_LOADED = true;
    return main();
  });

  W = settings.WIDTH;

  H = settings.HEIGHT;

  main = function() {
    var black, blurHandler, body, canvas, clear, clickHandler, container, contextMenuHandler, draw, event_catcher, focusHandler, game, keyDownListener, keyUpListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, queue, renderer, stage, update;

    body = $('body');
    container = $('<div>');
    container.css('margin-right', 'auto');
    container.css('margin-left', 'auto');
    container.css('width', "" + W + "px");
    body.append(container);
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(W, H);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    game = new Game(stage);
    onResize = function() {
      return log_input("resize");
    };
    keyDownListener = function(e) {
      log_input("key down:", e.keyCode);
      return game.onKeyDown(e.keyCode);
    };
    keyUpListener = function(e) {
      log_input("key up:", e.keyCode);
      return game.onKeyUp(e.keyCode);
    };
    onBeforeUnload = function(e) {
      return log_input("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      log_input("mouse:", x, y);
      return game.onMouseMove({
        x: x,
        y: y
      });
    };
    clickHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      return log_input("click:", x, y);
    };
    contextMenuHandler = function(e) {
      log_input("context menu");
      return false;
    };
    mouseDownHandler = function(e) {
      var x, y;

      log_input("mouse down");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseDown(e.button, {
        x: x,
        y: y
      });
    };
    mouseUpHandler = function(e) {
      var x, y;

      log_input("mouse up");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseUp(e.button, {
        x: x,
        y: y
      });
    };
    mouseOutHandler = function(e) {
      return log_input("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return log_input("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return log_input("focus");
    };
    blurHandler = function(e) {
      return log_input("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    document.body.addEventListener('keyup', keyUpListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.oncontextmenu = contextMenuHandler;
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      return game.update();
    };
    clear = function() {
      return game.clear();
    };
    draw = function() {
      game.draw();
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

  log_input = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (settings.PRINT_INPUT) {
      return console.log.apply(console, args);
    }
  };

  Paddle = (function() {
    function Paddle() {}

    return Paddle;

  })();

}).call(this);
