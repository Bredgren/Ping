// Generated by CoffeeScript 1.6.2
(function() {
  var CircleBall, DebugDraw, Game, H, Paddle, W, b2Collision, b2Common, b2Contacts, b2Controllers, b2DebugDraw, b2Dynamics, b2Joints, b2Math, b2Shapes, b2Vec2, log_input, main, settings,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  CircleBall = (function() {
    CircleBall.prototype.RADIUS = 15;

    CircleBall.prototype.MIN_X_VEL = 20;

    CircleBall.prototype.MAX_ANGLE = 60 / 180 * Math.PI;

    CircleBall.prototype.MAGNUS_SCALE = .05;

    function CircleBall(game, init_pos, init_vel) {
      var b2_radius, b2_x, b2_y, bodyDef, f, fixDef, g, t, vel;

      this.game = game;
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawCircle(0, 0, this.RADIUS);
      g.moveTo(0, 0);
      g.lineTo(0, this.RADIUS);
      t = g.generateTexture();
      this.sprite = new PIXI.Sprite(t);
      this.sprite.anchor.x = 0.5;
      this.sprite.anchor.y = 0.5;
      this.game.game_stage.addChild(this.sprite);
      b2_radius = this.RADIUS / settings.PPM;
      b2_x = init_pos.x / settings.PPM;
      b2_y = init_pos.y / settings.PPM;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 0.1;
      fixDef.friction = 0.5;
      fixDef.restitution = 1;
      fixDef.shape = new b2Shapes.b2CircleShape(b2_radius);
      this.body = this.game.world.CreateBody(bodyDef);
      this.body.CreateFixture(fixDef);
      f = this.body.GetFixtureList().GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BALL;
      this.body.GetFixtureList().SetFilterData(f);
      vel = new b2Vec2(init_vel.x / settings.PPM, init_vel.y / settings.PPM);
      this.body.SetLinearVelocity(vel);
    }

    CircleBall.prototype.update = function() {
      var angle, c, dif, f, mag, magnus_dir, magnus_force, magnus_unit, spin, target_angle, vel, x, y;

      vel = this.body.GetLinearVelocity();
      angle = Math.atan(vel.y / vel.x);
      if (Math.abs(angle) > this.MAX_ANGLE) {
        target_angle = (angle > 0 ? 1 : -1) * this.MAX_ANGLE;
        dif = target_angle - angle;
        x = vel.x * Math.cos(dif) - vel.y * Math.sin(dif);
        y = vel.x * Math.sin(dif) + vel.y * Math.cos(dif);
        vel.x = x;
        vel.y = y;
      }
      if (Math.abs(vel.x) < this.MIN_X_VEL) {
        vel.x = (vel.x > 0 ? 1 : -1) * this.MIN_X_VEL;
        this.body.SetLinearVelocity(vel);
      }
      this.body.SetLinearVelocity(vel);
      spin = this.body.GetAngularVelocity();
      magnus_dir = {
        x: -vel.y,
        y: vel.x
      };
      if (spin > 0) {
        magnus_dir.x *= -1;
        magnus_dir.y *= -1;
      }
      mag = Math.sqrt(magnus_dir.x * magnus_dir.x + magnus_dir.y * magnus_dir.y);
      magnus_unit = {
        x: magnus_dir.x / mag,
        y: magnus_dir.y / mag
      };
      mag = spin * this.MAGNUS_SCALE;
      magnus_force = new b2Vec2(magnus_unit.x * mag, magnus_unit.y * mag);
      this.body.ApplyForce(magnus_force, this.body.GetPosition());
      f = this.body.GetFixtureList().GetFilterData();
      c = settings.COLLISION_CATEGORY;
      if (vel.x > 0) {
        f.maskBits = c.BOUNDARY | c.PADDLE_R;
      } else {
        f.maskBits = c.BOUNDARY | c.PADDLE_L;
      }
      return this.body.GetFixtureList().SetFilterData(f);
    };

    CircleBall.prototype.draw = function() {
      var pos, rot;

      pos = this.body.GetPosition();
      rot = this.body.GetAngle();
      this.sprite.position.x = pos.x * settings.PPM;
      this.sprite.position.y = pos.y * settings.PPM;
      return this.sprite.rotation = rot;
    };

    CircleBall.prototype.destroy = function() {
      var body;

      body = this.game.world.GetBodyList();
      while (body) {
        if (body === this.body) {
          this.game.world.DestroyBody(body);
        }
        body = body.GetNext();
      }
      return this.game.game_stage.removeChild(this.sprite);
    };

    return CircleBall;

  })();

  settings = {
    DEBUG: true,
    DEBUG_DRAW: false,
    PRINT_INPUT: false,
    WIDTH: 1000,
    HEIGHT: 500,
    PADDLE_X: 20,
    PPM: 30,
    BOX2D_TIME_STEP: 1 / 60,
    BOX2D_VI: 10,
    BOX2D_PI: 10,
    BINDINGS: {
      P1_UP: 87,
      P1_DOWN: 83,
      P1_LEFT: 65,
      P1_RIGHT: 68,
      P2_UP: 38,
      P2_DOWN: 40,
      P2_LEFT: 37,
      P2_RIGHT: 39,
      START: 32,
      END: 27
    },
    COLLISION_CATEGORY: {
      PADDLE_L: 0x0001,
      PADDLE_R: 0x0002,
      BALL: 0x0004,
      BOUNDARY: 0x0008
    }
  };

  b2Common = Box2D.Common;

  b2Math = Box2D.Common.Math;

  b2Vec2 = b2Math.b2Vec2;

  b2Collision = Box2D.Collision;

  b2Shapes = Box2D.Collision.Shapes;

  b2Dynamics = Box2D.Dynamics;

  b2Contacts = Box2D.Dynamics.Contacts;

  b2Controllers = Box2D.Dynamics.Controllers;

  b2Joints = Box2D.Dynamics.Joints;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  DebugDraw = (function(_super) {
    __extends(DebugDraw, _super);

    function DebugDraw() {
      this._line_width = 1;
      this._alpha = 0.5;
      this._fill_alpha = 0.5;
      this.m_sprite = {
        graphics: {
          clear: function() {}
        }
      };
    }

    DebugDraw.prototype._worldToScreen = function(pos) {
      return {
        x: pos.x * settings.PPM,
        y: pos.y * settings.PPM
      };
    };

    DebugDraw.prototype.SetSprite = function(_graphics) {
      this._graphics = _graphics;
    };

    DebugDraw.prototype.GetSprite = function() {
      return this._graphics;
    };

    DebugDraw.prototype.DrawCircle = function(center, radius, color) {
      this._graphics.alpha = this._alpha;
      this._graphics.lineStyle(this._line_width, color.color);
      center = this._worldToScreen(center);
      return this._graphics.drawCircle(center.x, center.y, radius * settings.PPM);
    };

    DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
      var v, v0, _i, _len, _ref;

      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      v0 = vertices[0];
      v0 = this._worldToScreen(v0);
      this._graphics.moveTo(v0.x, v0.y);
      _ref = vertices.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v = this._worldToScreen(v);
        this._graphics.lineTo(v.x, v.y);
      }
      return this._graphics.lineTo(v0.x, v0.y);
    };

    DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      p1 = this._worldToScreen(p1);
      p2 = this._worldToScreen(p2);
      this._graphics.moveTo(p1.x, p1.y);
      return this._graphics.lineTo(p2.x, p2.y);
    };

    DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
      var edge;

      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawCircle(center, radius, color);
      this._graphics.endFill();
      axis = axis.Copy();
      axis.Normalize();
      axis.Multiply(radius);
      edge = center.Copy();
      edge.Add(axis);
      return this.DrawSegment(center, edge, color);
    };

    DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawPolygon(vertices, vertexCount, color);
      return this._graphics.endFill();
    };

    DebugDraw.prototype.DrawTransform = function(xf) {
      var p1, p2, p3;

      this._graphics.lineStyle(this._line_width, 0xFF0000);
      this._graphics.alpha = this._alpha;
      p1 = this._worldToScreen(xf.position);
      p2 = {
        x: xf.position.x + xf.R.col1.x,
        y: xf.position.y + xf.R.col1.y
      };
      p2 = this._worldToScreen(p2);
      p3 = {
        x: xf.position.x + xf.R.col2.x,
        y: xf.position.y + xf.R.col2.y
      };
      p3 = this._worldToScreen(p3);
      this._graphics.moveTo(p1.x, p1.y);
      this._graphics.lineTo(p2.x, p2.y);
      this._graphics.moveTo(p1.x, p1.y);
      return this._graphics.lineTo(p3.x, p3.y);
    };

    DebugDraw.prototype.GetAlpha = function() {
      return this._alpha;
    };

    DebugDraw.prototype.GetDrawScale = function() {
      return this._scale;
    };

    DebugDraw.prototype.GetFillAlpha = function() {
      return this._fill_alpha;
    };

    DebugDraw.prototype.GetLineThickness = function() {
      return this._line_width;
    };

    DebugDraw.prototype.SetAlpha = function(_alpha) {
      this._alpha = _alpha;
    };

    DebugDraw.prototype.SetDrawScale = function(_scale) {
      this._scale = _scale;
    };

    DebugDraw.prototype.SetLineThickness = function(_line_width) {
      this._line_width = _line_width;
    };

    return DebugDraw;

  })(b2Dynamics.b2DebugDraw);

  Paddle = (function() {
    Paddle.prototype.LENGTH = 75;

    Paddle.prototype.WIDTH = 10;

    Paddle.prototype.FORCE = 200;

    Paddle.prototype.MAX_VEL = 100;

    Paddle.prototype.ANGLE = 20;

    Paddle.prototype.DAMPING_MOVE = 0;

    Paddle.prototype.DAMPING_STILL = 5;

    Paddle.prototype.buttons = null;

    function Paddle(game, x, start_y) {
      var b2_length, b2_width, b2_x, b2_y, bodyDef, f, fix, fixDef, g, jointDef, t;

      this.game = game;
      if (start_y == null) {
        start_y = settings.HEIGHT / 2;
      }
      this.buttons = {
        up: false,
        down: false,
        left: false,
        right: false
      };
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, this.WIDTH, this.LENGTH);
      t = g.generateTexture();
      this.sprite = new PIXI.Sprite(t);
      this.sprite.anchor.x = 0.5;
      this.sprite.anchor.y = 0.5;
      this.game.game_stage.addChild(this.sprite);
      b2_width = this.WIDTH / settings.PPM;
      b2_length = this.LENGTH / settings.PPM;
      b2_x = x / settings.PPM;
      b2_y = start_y / settings.PPM;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      bodyDef.fixedRotation = true;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_width / 2, b2_length / 2);
      this.paddle_body = this.game.world.CreateBody(bodyDef);
      fix = this.paddle_body.CreateFixture(fixDef);
      f = fix.GetFilterData();
      if (x < settings.WIDTH / 2) {
        f.categoryBits = settings.COLLISION_CATEGORY.PADDLE_L;
      } else {
        f.categoryBits = settings.COLLISION_CATEGORY.PADDLE_R;
      }
      fix.SetFilterData(f);
      fixDef.density = 1;
      fixDef.friction = 0.0;
      fixDef.restitution = 0.0;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(0.1, 0.1);
      bodyDef.fixedRotation = false;
      this.anchor_body = this.game.world.CreateBody(bodyDef);
      fix = this.anchor_body.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = 0;
      fix.SetFilterData(f);
      jointDef = new b2Joints.b2PrismaticJointDef();
      jointDef.Initialize(this.game.top_boundary, this.anchor_body, new b2Vec2(b2_x, 0), new b2Vec2(0, 1));
      this.game.world.CreateJoint(jointDef);
      jointDef = new b2Joints.b2RevoluteJointDef();
      jointDef.Initialize(this.paddle_body, this.anchor_body, this.anchor_body.GetWorldCenter());
      this.game.world.CreateJoint(jointDef);
    }

    Paddle.prototype.position = function() {
      return this.paddle_body.GetPosition();
    };

    Paddle.prototype.destroy = function() {
      var body;

      body = this.game.world.GetBodyList();
      while (body) {
        if (body === this.anchor_body || body === this.paddle_body) {
          this.game.world.DestroyBody(body);
        }
        body = body.GetNext();
      }
      return this.game.game_stage.removeChild(this.sprite);
    };

    Paddle.prototype.update = function() {
      var body, dir, pos, spin, vel;

      body = this.paddle_body;
      pos = body.GetPosition();
      vel = body.GetLinearVelocity();
      spin = body.GetAngularVelocity();
      dir = new b2Vec2(0, 0);
      if (this.buttons.up !== this.buttons.down) {
        if (this.buttons.up) {
          dir = new b2Vec2(0, -1);
        } else if (this.buttons.down) {
          dir = new b2Vec2(0, 1);
        }
      }
      if (this.buttons.up || this.buttons.down) {
        body.SetLinearDamping(this.DAMPING_MOVE);
      } else {
        body.SetLinearDamping(this.DAMPING_STILL);
      }
      dir.Multiply(this.FORCE);
      body.ApplyForce(dir, pos);
      if (Math.abs(vel.x) > this.MAX_VEL) {
        vel.x = (vel.x > 0 ? 1 : -1) * this.MAX_VEL;
        body.SetLinearVelocity(vel);
      }
      if (Math.abs(vel.y) > this.MAX_VEL) {
        vel.y = (vel.y > 0 ? 1 : -1) * this.MAX_VEL;
        body.SetLinearVelocity(vel);
      }
      if (this.buttons.left !== this.buttons.right) {
        if (this.buttons.left) {
          body.SetAngle(-Math.PI / 180 * this.ANGLE);
        } else if (this.buttons.right) {
          body.SetAngle(Math.PI / 180 * this.ANGLE);
        }
      }
      if (!this.buttons.left && !this.buttons.right) {
        return body.SetAngle(0);
      }
    };

    Paddle.prototype.draw = function() {
      var pos, rot;

      pos = this.position();
      this.sprite.position.x = pos.x * settings.PPM;
      this.sprite.position.y = pos.y * settings.PPM;
      rot = this.paddle_body.GetAngle();
      return this.sprite.rotation = rot;
    };

    Paddle.prototype.startUp = function() {
      return this.buttons.up = true;
    };

    Paddle.prototype.endUp = function() {
      return this.buttons.up = false;
    };

    Paddle.prototype.startDown = function() {
      return this.buttons.down = true;
    };

    Paddle.prototype.endDown = function() {
      return this.buttons.down = false;
    };

    Paddle.prototype.startLeft = function() {
      return this.buttons.left = true;
    };

    Paddle.prototype.endLeft = function() {
      return this.buttons.left = false;
    };

    Paddle.prototype.startRight = function() {
      return this.buttons.right = true;
    };

    Paddle.prototype.endRight = function() {
      return this.buttons.right = false;
    };

    return Paddle;

  })();

  Game = (function() {
    Game.prototype.states = {
      MENU: 0,
      COUNT_DOWN: 1,
      GAME: 2,
      END: 3
    };

    Game.prototype.state = null;

    Game.prototype.left_paddle = null;

    Game.prototype.right_paddle = null;

    Game.prototype.ball = null;

    Game.prototype.time = 0;

    Game.prototype.time_limit = 60 * 2;

    Game.prototype.left_score = 0;

    Game.prototype.right_score = 0;

    Game.prototype._loop_time = 0;

    Game.prototype._count_down = 3;

    Game.prototype._player2_type = "human";

    Game.prototype.GRAD_TIME = 20;

    function Game(stage) {
      var ai_hard, ai_hard_selected, ai_norm, ai_norm_selected, b2_h, b2_w, b2_x, b2_y, bodyDef, c, count, cx, cy, debug_drawer, doSleep, f, fix, fixDef, g, h, human, human_selected, offset, rt, style, t, w, x, y, _i,
        _this = this;

      this.stage = stage;
      this.hud_stage = new PIXI.DisplayObjectContainer();
      this.game_stage = new PIXI.DisplayObjectContainer();
      this.bg_stage = new PIXI.DisplayObjectContainer();
      this.stage.addChild(this.bg_stage);
      this.stage.addChild(this.game_stage);
      this.stage.addChild(this.hud_stage);
      this.hud_graphics = new PIXI.Graphics();
      this.hud_stage.addChild(this.hud_graphics);
      cx = settings.WIDTH / 2;
      cy = settings.HEIGHT / 2;
      style = {
        font: "100px Arial",
        fill: "#FFFFFF"
      };
      this.title_text = new PIXI.Text("Ping", style);
      this.title_text.position.x = cx - this.title_text.width / 2;
      this.title_text.position.y = cy / 3;
      style = {
        font: "50px Arial",
        fill: "#FFFFFF"
      };
      this.victor_text = new PIXI.Text("Player 1 Wins!", style);
      this.victor_text.position.x = cx - this.victor_text.width / 2;
      this.victor_text.position.y = cy / 3;
      this.countdown_text = new PIXI.Text("3", style);
      this.countdown_text.position.x = cx - this.countdown_text.width / 2;
      this.countdown_text.position.y = cy / 3;
      style = {
        font: "20px Arial",
        fill: "#FFFFFF"
      };
      this.player1_text = new PIXI.Text("Player 1", style);
      this.player1_text.position.x = cx / 3 - this.player1_text.width / 2;
      this.player1_text.position.y = cy / 2;
      this.player2_text = new PIXI.Text("Player 2", style);
      this.player2_text.position.x = settings.WIDTH - cx / 3 - this.player2_text.width / 2;
      this.player2_text.position.y = cy / 2;
      this.controls1_text = new PIXI.Text("  W\nA S D", style);
      this.controls1_text.position.x = Math.round(cx / 3 - this.controls1_text.width / 2);
      this.controls1_text.position.y = Math.round(cy * 0.75);
      w = 75;
      h = 75;
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.moveTo(w / 2, h * 0.4);
      g.lineTo(w / 2, 0);
      g.lineTo(w * 0.4, h * 0.2);
      g.moveTo(w / 2, 0);
      g.lineTo(w * 0.6, h * 0.2);
      g.moveTo(w / 2, h * 0.6);
      g.lineTo(w / 2, h);
      g.lineTo(w * 0.4, h * 0.8);
      g.moveTo(w / 2, h);
      g.lineTo(w * 0.6, h * 0.8);
      g.moveTo(w * 0.4, h / 2);
      g.lineTo(0, h / 2);
      g.lineTo(w * 0.2, h * 0.4);
      g.moveTo(0, h / 2);
      g.lineTo(w * 0.2, h * 0.6);
      g.moveTo(w * 0.6, h / 2);
      g.lineTo(w, h / 2);
      g.lineTo(w * 0.8, h * 0.4);
      g.moveTo(w, h / 2);
      g.lineTo(w * 0.8, h * 0.6);
      this.controls2 = new PIXI.Sprite(g.generateTexture());
      this.controls2.position.x = Math.round(settings.WIDTH - cx * 0.6 - this.controls2.width / 2);
      this.controls2.position.y = Math.round(cy * 0.65);
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("Human", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      human = rt;
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("Human", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      human_selected = rt;
      this.human_box = new PIXI.Sprite(human_selected);
      this.human_box.interactive = true;
      this.human_box.hitArea = new PIXI.Rectangle(0, 0, 75, 25);
      this.human_box.selected = true;
      this.human_box.setSelected = function(val) {
        if (val !== this.selected) {
          if (val) {
            this.selected = true;
            return this.setTexture(human_selected);
          } else {
            this.selected = false;
            return this.setTexture(human);
          }
        }
      };
      this.human_box.mouseover = function(data) {
        return this.setTexture(human_selected);
      };
      this.human_box.mouseout = function(data) {
        if (!this.selected) {
          return this.setTexture(human);
        }
      };
      this.human_box.click = function(data) {
        _this.ai_norm_box.setSelected(false);
        _this.ai_hard_box.setSelected(false);
        data.target.setSelected(true);
        return _this._onSelectHuman();
      };
      x = settings.WIDTH - cx / 3;
      y = cy * 0.7;
      this.human_box.x = Math.round(x - this.human_box.width / 2);
      this.human_box.y = Math.round(y - this.human_box.height / 2);
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("Normal AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_norm = rt;
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("Normal AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_norm_selected = rt;
      this.ai_norm_box = new PIXI.Sprite(ai_norm);
      this.ai_norm_box.interactive = true;
      this.ai_norm_box.hitArea = new PIXI.Rectangle(0, 0, 75, 25);
      this.ai_norm_box.selected = false;
      this.ai_norm_box.setSelected = function(val) {
        if (val !== this.selected) {
          if (val) {
            this.selected = true;
            return this.setTexture(ai_norm_selected);
          } else {
            this.selected = false;
            return this.setTexture(ai_norm);
          }
        }
      };
      this.ai_norm_box.mouseover = function(data) {
        return this.setTexture(ai_norm_selected);
      };
      this.ai_norm_box.mouseout = function(data) {
        if (!this.selected) {
          return this.setTexture(ai_norm);
        }
      };
      this.ai_norm_box.click = function(data) {
        _this.human_box.setSelected(false);
        _this.ai_hard_box.setSelected(false);
        data.target.setSelected(true);
        return _this._onSelectNormAI();
      };
      x = settings.WIDTH - cx / 3;
      y = cy * 0.7 + 25 + 10;
      this.ai_norm_box.x = Math.round(x - this.ai_norm_box.width / 2);
      this.ai_norm_box.y = Math.round(y - this.ai_norm_box.height / 2);
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("Hard AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_hard = rt;
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("Hard AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_hard_selected = rt;
      this.ai_hard_box = new PIXI.Sprite(ai_hard);
      this.ai_hard_box.interactive = true;
      this.ai_hard_box.hitArea = new PIXI.Rectangle(0, 0, 75, 25);
      this.ai_hard_box.selected = false;
      this.ai_hard_box.setSelected = function(val) {
        if (val !== this.selected) {
          if (val) {
            this.selected = true;
            return this.setTexture(ai_hard_selected);
          } else {
            this.selected = false;
            return this.setTexture(ai_hard);
          }
        }
      };
      this.ai_hard_box.mouseover = function(data) {
        return this.setTexture(ai_hard_selected);
      };
      this.ai_hard_box.mouseout = function(data) {
        if (!this.selected) {
          return this.setTexture(ai_hard);
        }
      };
      this.ai_hard_box.click = function(data) {
        _this.human_box.setSelected(false);
        _this.ai_norm_box.setSelected(false);
        data.target.setSelected(true);
        return _this._onSelectHardAI();
      };
      x = settings.WIDTH - cx / 3;
      y = cy * 0.7 + 2 * (25 + 10);
      this.ai_hard_box.x = Math.round(x - this.ai_hard_box.width / 2);
      this.ai_hard_box.y = Math.round(y - this.ai_hard_box.height / 2);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.begin_text = new PIXI.Text("Press SPACE to begin", style);
      this.quit_text = new PIXI.Text("Press ESC to quit", style);
      this.return_text = new PIXI.Text("Press SPACE to return to menu", style);
      this.begin_text.position.x = Math.round(cx - this.begin_text.width / 2);
      this.begin_text.position.y = Math.round(cy - this.begin_text.height / 2);
      this.quit_text.position.x = 0;
      this.quit_text.position.y = 0;
      this.return_text.position.x = Math.round(cx - this.return_text.width / 2);
      this.return_text.position.y = Math.round(cy - this.return_text.height / 2);
      style = {
        font: "25px Arial",
        fill: "#FFFFFF"
      };
      this.time_text = new PIXI.Text("000", style);
      this.time_text.position.x = settings.WIDTH / 2 - this.time_text.width / 2;
      this.time_text.position.y = 10;
      style = {
        font: "30px Arial",
        fill: "#FFFFFF"
      };
      this.left_score_text = new PIXI.Text("", style);
      this.left_score_text.position.x = settings.WIDTH / 4;
      this.left_score_text.position.y = 10;
      this.right_score_text = new PIXI.Text("", style);
      this.right_score_text.position.x = 3 * settings.WIDTH / 4;
      this.right_score_text.position.y = 10;
      g = new PIXI.Graphics();
      count = 20;
      for (x = _i = 0; 0 <= count ? _i < count : _i > count; x = 0 <= count ? ++_i : --_i) {
        g.lineStyle(1, 0xFFFFFF, 1 - (x / count));
        g.moveTo(x, 0);
        g.lineTo(x, settings.HEIGHT);
      }
      this.score_grad = new PIXI.Sprite(g.generateTexture());
      this.score_grad.anchor.x = 11 / this.score_grad.width;
      this.score_grad.anchor.y = 11 / this.score_grad.height;
      this.world = new b2Dynamics.b2World(new b2Vec2(0, 0), doSleep = false);
      if (settings.DEBUG_DRAW) {
        debug_drawer = new DebugDraw();
        debug_drawer.SetSprite(this.hud_graphics);
        debug_drawer.SetDrawScale(1);
        debug_drawer.SetAlpha(1);
        debug_drawer.SetFillAlpha(1);
        debug_drawer.SetLineThickness(1.0);
        debug_drawer.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit | b2DebugDraw.e_centerOfMassBit | b2DebugDraw.e_controllerBit | b2DebugDraw.e_pairBit | b2DebugDraw.e_aabbBit);
        this.world.SetDebugDraw(debug_drawer);
      }
      b2_w = settings.WIDTH / settings.PPM;
      b2_h = 1;
      offset = b2_h / 2;
      b2_x = b2_w / 2;
      b2_y = -offset;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_staticBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.top_boundary = this.world.CreateBody(bodyDef);
      fix = this.top_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      bodyDef.position.x = b2_x;
      bodyDef.position.y = settings.HEIGHT / settings.PPM + offset;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.bottom_boundary = this.world.CreateBody(bodyDef);
      fix = this.bottom_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      b2_w = b2_h;
      b2_h = settings.HEIGHT / settings.PPM;
      b2_x = -offset;
      b2_y = b2_h / 2;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.left_boundary = this.world.CreateBody(bodyDef);
      fix = this.left_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      b2_x = settings.WIDTH / settings.PPM + offset;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.right_boundary = this.world.CreateBody(bodyDef);
      fix = this.right_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      this.gotoMenu();
    }

    Game.prototype.update = function() {
      var dt, t;

      t = (new Date()).getTime();
      dt = t - this._loop_time;
      this._loop_time = t;
      if (this.state === this.states.COUNT_DOWN) {
        this._count_down -= dt / 1000;
        if (this._count_down <= 0) {
          this.state = this.states.GAME;
          this.hud_stage.removeChild(this.countdown_text);
        }
        this.countdown_text.setText("" + Math.round(this._count_down));
      } else if (this.state === this.states.GAME) {
        this.time -= dt / 1000;
        t = "" + Math.round(this.time);
        if (t.length === 1) {
          t = "00" + t;
        } else if (t.length === 2) {
          t = "0" + t;
        }
        this.time_text.setText(t);
        if (this.time <= 0) {
          this.endGame();
          return;
        }
        this.left_paddle.update();
        this.right_paddle.update();
        this.ball.update();
        this.world.Step(settings.BOX2D_TIME_STEP, settings.BOX2D_VI, settings.BOX2D_PI);
        this.world.ClearForces();
        this._checkContacts();
      }
      if (this._score_counter > 0) {
        this._score_counter--;
        this.score_grad.alpha = this._score_counter / this.GRAD_TIME;
        if (this._score_counter <= 0) {
          return this.hud_stage.removeChild(this.score_grad);
        }
      }
    };

    Game.prototype.clear = function() {
      return this.hud_graphics.clear();
    };

    Game.prototype.draw = function() {
      if (this.state === this.states.GAME || this.state === this.states.COUNT_DOWN) {
        this.left_paddle.draw();
        this.right_paddle.draw();
        this.ball.draw();
        if (settings.DEBUG_DRAW) {
          return this.world.DrawDebugData();
        }
      }
    };

    Game.prototype.scoreRight = function() {
      this.right_score++;
      this.right_score_text.setText("" + this.right_score);
      this.score_grad.scale.x = 1;
      this.score_grad.position.x = 0;
      this.hud_stage.addChild(this.score_grad);
      return this._score_counter = this.GRAD_TIME;
    };

    Game.prototype.scoreLeft = function() {
      this.left_score++;
      this.left_score_text.setText("" + this.left_score);
      this.score_grad.scale.x = -1;
      this.score_grad.position.x = settings.WIDTH;
      this.hud_stage.addChild(this.score_grad);
      return this._score_counter = this.GRAD_TIME;
    };

    Game.prototype.startGame = function() {
      var center, t, vel, _ref, _ref1, _ref2, _ref3;

      this.state = this.states.COUNT_DOWN;
      this._count_down = 3;
      this.hud_stage.removeChild(this.begin_text);
      this.hud_stage.removeChild(this.title_text);
      this.hud_stage.removeChild(this.player1_text);
      this.hud_stage.removeChild(this.player2_text);
      this.hud_stage.removeChild(this.controls1_text);
      if (_ref = this.controls2, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        this.hud_stage.removeChild(this.controls2);
      }
      if (_ref1 = this.human_box, __indexOf.call(this.hud_stage.children, _ref1) >= 0) {
        this.hud_stage.removeChild(this.human_box);
      }
      if (_ref2 = this.ai_norm_box, __indexOf.call(this.hud_stage.children, _ref2) >= 0) {
        this.hud_stage.removeChild(this.ai_norm_box);
      }
      if (_ref3 = this.ai_hard_box, __indexOf.call(this.hud_stage.children, _ref3) >= 0) {
        this.hud_stage.removeChild(this.ai_hard_box);
      }
      this.hud_stage.addChild(this.quit_text);
      this.hud_stage.addChild(this.countdown_text);
      this.left_paddle = new Paddle(this, settings.PADDLE_X);
      this.right_paddle = new Paddle(this, settings.WIDTH - settings.PADDLE_X);
      center = {
        x: settings.WIDTH / 2,
        y: settings.HEIGHT / 2
      };
      vel = {
        x: -50,
        y: 0
      };
      this.ball = new CircleBall(this, center, vel);
      this.time = this.time_limit;
      this.left_score = 0;
      this.right_score = 0;
      t = "" + Math.round(this.time);
      if (t.length === 1) {
        t = "00" + t;
      } else if (t.length === 2) {
        t = "0" + t;
      }
      this.time_text.setText(t);
      this.left_score_text.setText("" + this.left_score);
      this.right_score_text.setText("" + this.right_score);
      this.hud_stage.addChild(this.time_text);
      this.hud_stage.addChild(this.left_score_text);
      return this.hud_stage.addChild(this.right_score_text);
    };

    Game.prototype.endGame = function() {
      this.state = this.states.END;
      this.hud_stage.removeChild(this.quit_text);
      this.hud_stage.addChild(this.return_text);
      if (this.left_score > this.right_score) {
        this.victor_text.setText("Player 1 Wins!");
      } else if (this.left_score < this.right_score) {
        this.victor_text.setText("Player 2 Wins!");
      } else {
        this.victor_text.setText("Player 3 Wins?!");
      }
      this.hud_stage.addChild(this.victor_text);
      this.left_paddle.destroy();
      this.right_paddle.destroy();
      return this.ball.destroy();
    };

    Game.prototype.gotoMenu = function() {
      var _ref, _ref1, _ref2, _ref3, _ref4;

      this.state = this.states.MENU;
      this.hud_stage.addChild(this.begin_text);
      this.hud_stage.addChild(this.title_text);
      this.hud_stage.addChild(this.player1_text);
      this.hud_stage.addChild(this.player2_text);
      this.hud_stage.addChild(this.controls1_text);
      if (this._player2_type === "human") {
        this.hud_stage.addChild(this.controls2);
      }
      this.hud_stage.addChild(this.human_box);
      this.hud_stage.addChild(this.ai_norm_box);
      this.hud_stage.addChild(this.ai_hard_box);
      if (_ref = this.return_text, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        this.hud_stage.removeChild(this.return_text);
      }
      if (_ref1 = this.time_text, __indexOf.call(this.hud_stage.children, _ref1) >= 0) {
        this.hud_stage.removeChild(this.time_text);
      }
      if (_ref2 = this.left_score_text, __indexOf.call(this.hud_stage.children, _ref2) >= 0) {
        this.hud_stage.removeChild(this.left_score_text);
      }
      if (_ref3 = this.right_score_text, __indexOf.call(this.hud_stage.children, _ref3) >= 0) {
        this.hud_stage.removeChild(this.right_score_text);
      }
      if (_ref4 = this.victor_text, __indexOf.call(this.hud_stage.children, _ref4) >= 0) {
        return this.hud_stage.removeChild(this.victor_text);
      }
    };

    Game.prototype.onKeyDown = function(key_code) {
      var bindings;

      bindings = settings.BINDINGS;
      if (this.state === this.states.GAME) {
        switch (key_code) {
          case bindings.P1_UP:
            this.left_paddle.startUp();
            break;
          case bindings.P1_DOWN:
            this.left_paddle.startDown();
            break;
          case bindings.P1_LEFT:
            this.left_paddle.startLeft();
            break;
          case bindings.P1_RIGHT:
            this.left_paddle.startRight();
            break;
          case bindings.P2_UP:
            this.right_paddle.startUp();
            break;
          case bindings.P2_DOWN:
            this.right_paddle.startDown();
            break;
          case bindings.P2_LEFT:
            this.right_paddle.startLeft();
            break;
          case bindings.P2_RIGHT:
            this.right_paddle.startRight();
        }
      }
      if (key_code === bindings.START) {
        switch (this.state) {
          case this.states.MENU:
            this.startGame();
            break;
          case this.states.END:
            this.gotoMenu();
        }
      }
      if (key_code === bindings.END && this.state === this.states.GAME) {
        return this.endGame();
      }
    };

    Game.prototype.onKeyUp = function(key_code) {
      var bindings;

      if (this.state !== this.states.GAME) {
        return;
      }
      bindings = settings.BINDINGS;
      switch (key_code) {
        case bindings.P1_UP:
          return this.left_paddle.endUp();
        case bindings.P1_DOWN:
          return this.left_paddle.endDown();
        case bindings.P1_LEFT:
          return this.left_paddle.endLeft();
        case bindings.P1_RIGHT:
          return this.left_paddle.endRight();
        case bindings.P2_UP:
          return this.right_paddle.endUp();
        case bindings.P2_DOWN:
          return this.right_paddle.endDown();
        case bindings.P2_LEFT:
          return this.right_paddle.endLeft();
        case bindings.P2_RIGHT:
          return this.right_paddle.endRight();
      }
    };

    Game.prototype.onMouseDown = function(button, screen_pos) {};

    Game.prototype.onMouseUp = function(button, screen_pos) {};

    Game.prototype.onMouseMove = function(screen_pos) {};

    Game.prototype.onMouseWheel = function(delta) {};

    Game.prototype._onSelectHuman = function() {
      this._player2_type = "human";
      return this.hud_stage.addChild(this.controls2);
    };

    Game.prototype._onSelectNormAI = function() {
      this._player2_type = "normal ai";
      return this.hud_stage.removeChild(this.controls2);
    };

    Game.prototype._onSelectHardAI = function() {
      this._player2_type = "hard ai";
      return this.hud_stage.removeChild(this.controls2);
    };

    Game.prototype._checkContacts = function() {
      var ball, bodyA, bodyB, contact, vel, _results;

      contact = this.world.GetContactList();
      _results = [];
      while (contact) {
        if (contact.IsTouching()) {
          bodyA = contact.GetFixtureA().GetBody();
          bodyB = contact.GetFixtureB().GetBody();
          if (bodyA === this.ball.body || bodyB === this.ball.body) {
            if (bodyA === this.left_boundary || bodyB === this.left_boundary) {
              this.scoreRight();
            } else if (bodyA === this.right_boundary || bodyB === this.right_boundary) {
              this.scoreLeft();
            } else if (bodyA === this.left_paddle.paddle_body || bodyB === this.left_paddle.paddle_body) {
              ball = this.ball.body;
              vel = ball.GetLinearVelocity();
              if (vel.x > 0) {
                contact.SetEnabled(false);
              }
            } else if (bodyA === this.right_paddle.paddle_body || bodyB === this.right_paddle.paddle_body) {
              ball = this.ball.body;
              vel = ball.GetLinearVelocity();
              if (vel.x < 0) {
                contact.SetEnabled(false);
              }
            }
          }
        }
        _results.push(contact = contact.GetNext());
      }
      return _results;
    };

    return Game;

  })();

  $(function() {
    var DOM_LOADED;

    DOM_LOADED = true;
    return main();
  });

  W = settings.WIDTH;

  H = settings.HEIGHT;

  main = function() {
    var black, blurHandler, body, canvas, clear, clickHandler, container, contextMenuHandler, draw, event_catcher, focusHandler, game, keyDownListener, keyUpListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, queue, renderer, stage, update;

    body = $('body');
    container = $('<div>');
    container.css('margin-right', 'auto');
    container.css('margin-left', 'auto');
    container.css('width', "" + W + "px");
    body.append(container);
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(W, H);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    game = new Game(stage);
    onResize = function() {
      return log_input("resize");
    };
    keyDownListener = function(e) {
      log_input("key down:", e.keyCode);
      return game.onKeyDown(e.keyCode);
    };
    keyUpListener = function(e) {
      log_input("key up:", e.keyCode);
      return game.onKeyUp(e.keyCode);
    };
    onBeforeUnload = function(e) {
      return log_input("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      log_input("mouse:", x, y);
      return game.onMouseMove({
        x: x,
        y: y
      });
    };
    clickHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      return log_input("click:", x, y);
    };
    contextMenuHandler = function(e) {
      log_input("context menu");
      return false;
    };
    mouseDownHandler = function(e) {
      var x, y;

      log_input("mouse down");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseDown(e.button, {
        x: x,
        y: y
      });
    };
    mouseUpHandler = function(e) {
      var x, y;

      log_input("mouse up");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseUp(e.button, {
        x: x,
        y: y
      });
    };
    mouseOutHandler = function(e) {
      return log_input("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return log_input("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return log_input("focus");
    };
    blurHandler = function(e) {
      return log_input("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    document.body.addEventListener('keyup', keyUpListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.oncontextmenu = contextMenuHandler;
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      return game.update();
    };
    clear = function() {
      return game.clear();
    };
    draw = function() {
      game.draw();
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

  log_input = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (settings.PRINT_INPUT) {
      return console.log.apply(console, args);
    }
  };

}).call(this);
