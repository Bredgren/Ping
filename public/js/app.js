// Generated by CoffeeScript 1.6.2
(function() {
  var CircleBall, Game, H, Paddle, W, b2Collision, b2Common, b2Contacts, b2Controllers, b2DebugDraw, b2Dynamics, b2Joints, b2Math, b2Shapes, b2Vec2, log_input, main, settings,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  CircleBall = (function() {
    function CircleBall() {}

    return CircleBall;

  })();

  settings = {
    DEBUG: true,
    PRINT_INPUT: false,
    WIDTH: 1000,
    HEIGHT: 500,
    PADDLE_X: 20,
    PPM: 30,
    BOX2D_TIME_STEP: 1 / 60,
    BOX2D_VI: 10,
    BOX2D_PI: 10,
    BINDINGS: {
      P1_UP: 87,
      P1_DOWN: 83,
      P1_LEFT: 65,
      P1_RIGHT: 68,
      P2_UP: 38,
      P2_DOWN: 40,
      P2_LEFT: 37,
      P2_RIGHT: 39,
      START: 32
    }
  };

  b2Common = Box2D.Common;

  b2Math = Box2D.Common.Math;

  b2Vec2 = b2Math.b2Vec2;

  b2Collision = Box2D.Collision;

  b2Shapes = Box2D.Collision.Shapes;

  b2Dynamics = Box2D.Dynamics;

  b2Contacts = Box2D.Dynamics.Contacts;

  b2Controllers = Box2D.Dynamics.Controllers;

  b2Joints = Box2D.Dynamics.Joints;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  Paddle = (function() {
    Paddle.prototype.LENGTH = 75;

    Paddle.prototype.WIDTH = 10;

    Paddle.prototype.FORCE = 200;

    Paddle.prototype.MAX_VEL = 100;

    Paddle.prototype.DAMPING_MOVE = 0;

    Paddle.prototype.DAMPING_STILL = 5;

    Paddle.prototype.buttons = {
      up: false,
      down: false,
      left: false,
      right: false
    };

    function Paddle(game, x, start_y) {
      var b2_length, b2_width, b2_x, b2_y, bodyDef, fixDef, g, t;

      this.game = game;
      if (start_y == null) {
        start_y = settings.HEIGHT / 2;
      }
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, this.WIDTH, this.LENGTH);
      t = g.generateTexture();
      this.sprite = new PIXI.Sprite(t);
      this.sprite.anchor.x = 0.5;
      this.sprite.anchor.y = 0.5;
      this.game.game_stage.addChild(this.sprite);
      b2_width = this.WIDTH / settings.PPM;
      b2_length = this.LENGTH / settings.PPM;
      b2_x = x / settings.PPM;
      b2_y = start_y / settings.PPM;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_width / 2, b2_length / 2);
      this.body = this.game.world.CreateBody(bodyDef);
      this.body.CreateFixture(fixDef);
    }

    Paddle.prototype.position = function() {
      return this.body.GetPosition();
    };

    Paddle.prototype.update = function() {
      var dir, pos, vel;

      pos = this.body.GetPosition();
      vel = this.body.GetLinearVelocity();
      dir = new b2Vec2(0, 0);
      if (this.buttons.up !== this.buttons.down) {
        if (this.buttons.up) {
          dir = new b2Vec2(0, -1);
        } else if (this.buttons.down) {
          dir = new b2Vec2(0, 1);
        }
      }
      if (this.buttons.up || this.buttons.down) {
        this.body.SetLinearDamping(this.DAMPING_MOVE);
      } else {
        this.body.SetLinearDamping(this.DAMPING_STILL);
      }
      dir.Multiply(this.FORCE);
      this.body.ApplyForce(dir, pos);
      if (Math.abs(vel.x) > this.MAX_VEL) {
        vel.x = (vel.x > 0 ? 1 : -1) * this.MAX_VEL;
        this.body.SetLinearVelocity(vel);
      }
      if (Math.abs(vel.y) > this.MAX_VEL) {
        vel.y = (vel.y > 0 ? 1 : -1) * this.MAX_VEL;
        return this.body.SetLinearVelocity(vel);
      }
    };

    Paddle.prototype.draw = function() {
      var pos;

      pos = this.position();
      this.sprite.position.x = pos.x * settings.PPM;
      return this.sprite.position.y = pos.y * settings.PPM;
    };

    Paddle.prototype.startUp = function() {
      return this.buttons.up = true;
    };

    Paddle.prototype.endUp = function() {
      return this.buttons.up = false;
    };

    Paddle.prototype.startDown = function() {
      return this.buttons.down = true;
    };

    Paddle.prototype.endDown = function() {
      return this.buttons.down = false;
    };

    return Paddle;

  })();

  Game = (function() {
    Game.prototype.states = {
      MENU: 0,
      GAME: 1,
      END: 2
    };

    Game.prototype.state = null;

    Game.prototype.left_paddle = null;

    Game.prototype.right_paddle = null;

    function Game(stage) {
      var b2_h, b2_w, b2_x, b2_y, bodyDef, cx, cy, doSleep, fixDef, offset, style;

      this.stage = stage;
      this.hud_stage = new PIXI.DisplayObjectContainer();
      this.game_stage = new PIXI.DisplayObjectContainer();
      this.bg_stage = new PIXI.DisplayObjectContainer();
      this.stage.addChild(this.bg_stage);
      this.stage.addChild(this.game_stage);
      this.stage.addChild(this.hud_stage);
      this.hud_graphics = new PIXI.Graphics();
      this.hud_stage.addChild(this.hud_graphics);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.begin_text = new PIXI.Text("Press SPACE to begin", style);
      this.return_text = new PIXI.Text("Press SPACE to return to menu", style);
      cx = settings.WIDTH / 2;
      cy = settings.HEIGHT / 2;
      this.begin_text.position.x = Math.round(cx - this.begin_text.width / 2);
      this.begin_text.position.y = Math.round(cy - this.begin_text.height / 2);
      this.return_text.position.x = Math.round(cx - this.return_text.width / 2);
      this.return_text.position.y = Math.round(cy - this.return_text.height / 2);
      this.world = new b2Dynamics.b2World(new b2Vec2(0, 0), doSleep = false);
      b2_w = settings.WIDTH / settings.PPM;
      b2_h = 1;
      offset = b2_h / 2;
      b2_x = 0;
      b2_y = -offset;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_staticBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.top_boundary = this.world.CreateBody(bodyDef);
      this.top_boundary.CreateFixture(fixDef);
      bodyDef.position.x = b2_x;
      bodyDef.position.y = settings.HEIGHT / settings.PPM + offset;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.bottom_boundary = this.world.CreateBody(bodyDef);
      this.bottom_boundary.CreateFixture(fixDef);
      this.left_paddle = new Paddle(this, settings.PADDLE_X);
      this.right_paddle = new Paddle(this, settings.WIDTH - settings.PADDLE_X);
      this.gotoMenu();
    }

    Game.prototype.update = function() {
      this.left_paddle.update();
      this.world.Step(settings.BOX2D_TIME_STEP, settings.BOX2D_VI, settings.BOX2D_PI);
      return this.world.ClearForces();
    };

    Game.prototype.clear = function() {
      return this.hud_graphics.clear();
    };

    Game.prototype.draw = function() {
      this.left_paddle.draw();
      return this.right_paddle.draw();
    };

    Game.prototype.startGame = function() {
      this.state = this.states.GAME;
      return this.hud_stage.removeChild(this.begin_text);
    };

    Game.prototype.endGame = function() {
      this.state = this.states.END;
      return this.hud_stage.addChild(this.return_text);
    };

    Game.prototype.gotoMenu = function() {
      var _ref;

      this.state = this.states.MENU;
      this.hud_stage.addChild(this.begin_text);
      if (_ref = this.return_text, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        return this.hud_stage.removeChild(this.return_text);
      }
    };

    Game.prototype.onKeyDown = function(key_code) {
      var bindings;

      bindings = settings.BINDINGS;
      switch (key_code) {
        case bindings.P1_UP:
          return this.left_paddle.startUp();
        case bindings.P1_DOWN:
          return this.left_paddle.startDown();
        case bindings.P1_LEFT:
          return console.log('left1');
        case bindings.P1_RIGHT:
          return console.log('right1');
        case bindings.P2_UP:
          return console.log('up2');
        case bindings.P2_DOWN:
          return console.log('down2');
        case bindings.P2_LEFT:
          return console.log('left2');
        case bindings.P2_RIGHT:
          return console.log('right2');
        case bindings.START:
          switch (this.state) {
            case this.states.MENU:
              return this.startGame();
            case this.states.END:
              return this.gotoMenu();
            case this.states.GAME:
              return this.endGame();
          }
      }
    };

    Game.prototype.onKeyUp = function(key_code) {
      var bindings;

      bindings = settings.BINDINGS;
      switch (key_code) {
        case bindings.P1_UP:
          return this.left_paddle.endUp();
        case bindings.P1_DOWN:
          return this.left_paddle.endDown();
        case bindings.P1_LEFT:
          return console.log('left1');
        case bindings.P1_RIGHT:
          return console.log('right1');
        case bindings.P2_UP:
          return console.log('up2');
        case bindings.P2_DOWN:
          return console.log('down2');
        case bindings.P2_LEFT:
          return console.log('left2');
        case bindings.P2_RIGHT:
          return console.log('right2');
      }
    };

    Game.prototype.onMouseDown = function(button, screen_pos) {};

    Game.prototype.onMouseUp = function(button, screen_pos) {};

    Game.prototype.onMouseMove = function(screen_pos) {};

    Game.prototype.onMouseWheel = function(delta) {};

    return Game;

  })();

  $(function() {
    var DOM_LOADED;

    DOM_LOADED = true;
    return main();
  });

  W = settings.WIDTH;

  H = settings.HEIGHT;

  main = function() {
    var black, blurHandler, body, canvas, clear, clickHandler, container, contextMenuHandler, draw, event_catcher, focusHandler, game, keyDownListener, keyUpListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, queue, renderer, stage, update;

    body = $('body');
    container = $('<div>');
    container.css('margin-right', 'auto');
    container.css('margin-left', 'auto');
    container.css('width', "" + W + "px");
    body.append(container);
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(W, H);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    game = new Game(stage);
    onResize = function() {
      return log_input("resize");
    };
    keyDownListener = function(e) {
      log_input("key down:", e.keyCode);
      return game.onKeyDown(e.keyCode);
    };
    keyUpListener = function(e) {
      log_input("key up:", e.keyCode);
      return game.onKeyUp(e.keyCode);
    };
    onBeforeUnload = function(e) {
      return log_input("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      log_input("mouse:", x, y);
      return game.onMouseMove({
        x: x,
        y: y
      });
    };
    clickHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      return log_input("click:", x, y);
    };
    contextMenuHandler = function(e) {
      log_input("context menu");
      return false;
    };
    mouseDownHandler = function(e) {
      var x, y;

      log_input("mouse down");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseDown(e.button, {
        x: x,
        y: y
      });
    };
    mouseUpHandler = function(e) {
      var x, y;

      log_input("mouse up");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseUp(e.button, {
        x: x,
        y: y
      });
    };
    mouseOutHandler = function(e) {
      return log_input("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return log_input("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return log_input("focus");
    };
    blurHandler = function(e) {
      return log_input("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    document.body.addEventListener('keyup', keyUpListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.oncontextmenu = contextMenuHandler;
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      return game.update();
    };
    clear = function() {
      return game.clear();
    };
    draw = function() {
      game.draw();
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

  log_input = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (settings.PRINT_INPUT) {
      return console.log.apply(console, args);
    }
  };

}).call(this);
