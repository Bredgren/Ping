// Generated by CoffeeScript 1.6.2
(function() {
  var CircleBall, DebugDraw, Game, H, Paddle, W, b2Collision, b2Common, b2Contacts, b2Controllers, b2DebugDraw, b2Dynamics, b2Joints, b2Math, b2Shapes, b2Vec2, log_input, main, settings,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  CircleBall = (function() {
    function CircleBall() {}

    return CircleBall;

  })();

  settings = {
    DEBUG: true,
    DEBUG_DRAW: true,
    PRINT_INPUT: false,
    WIDTH: 1000,
    HEIGHT: 500,
    PADDLE_X: 20,
    PPM: 30,
    BOX2D_TIME_STEP: 1 / 60,
    BOX2D_VI: 10,
    BOX2D_PI: 10,
    BINDINGS: {
      P1_UP: 87,
      P1_DOWN: 83,
      P1_LEFT: 65,
      P1_RIGHT: 68,
      P2_UP: 38,
      P2_DOWN: 40,
      P2_LEFT: 37,
      P2_RIGHT: 39,
      START: 32
    }
  };

  b2Common = Box2D.Common;

  b2Math = Box2D.Common.Math;

  b2Vec2 = b2Math.b2Vec2;

  b2Collision = Box2D.Collision;

  b2Shapes = Box2D.Collision.Shapes;

  b2Dynamics = Box2D.Dynamics;

  b2Contacts = Box2D.Dynamics.Contacts;

  b2Controllers = Box2D.Dynamics.Controllers;

  b2Joints = Box2D.Dynamics.Joints;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  DebugDraw = (function(_super) {
    __extends(DebugDraw, _super);

    function DebugDraw() {
      this._line_width = 1;
      this._alpha = 0.5;
      this._fill_alpha = 0.5;
      this.m_sprite = {
        graphics: {
          clear: function() {}
        }
      };
    }

    DebugDraw.prototype._worldToScreen = function(pos) {
      return {
        x: pos.x * settings.PPM,
        y: pos.y * settings.PPM
      };
    };

    DebugDraw.prototype.SetSprite = function(_graphics) {
      this._graphics = _graphics;
    };

    DebugDraw.prototype.GetSprite = function() {
      return this._graphics;
    };

    DebugDraw.prototype.DrawCircle = function(center, radius, color) {
      this._graphics.alpha = this._alpha;
      this._graphics.lineStyle(this._line_width, color.color);
      center = this._worldToScreen(center);
      return this._graphics.drawCircle(center.x, center.y, radius * settings.PPM);
    };

    DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
      var v, v0, _i, _len, _ref;

      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      v0 = vertices[0];
      v0 = this._worldToScreen(v0);
      this._graphics.moveTo(v0.x, v0.y);
      _ref = vertices.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v = this._worldToScreen(v);
        this._graphics.lineTo(v.x, v.y);
      }
      return this._graphics.lineTo(v0.x, v0.y);
    };

    DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      p1 = this._worldToScreen(p1);
      p2 = this._worldToScreen(p2);
      this._graphics.moveTo(p1.x, p1.y);
      return this._graphics.lineTo(p2.x, p2.y);
    };

    DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
      var edge;

      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawCircle(center, radius, color);
      this._graphics.endFill();
      axis = axis.Copy();
      axis.Normalize();
      axis.Multiply(radius);
      edge = center.Copy();
      edge.Add(axis);
      return this.DrawSegment(center, edge, color);
    };

    DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawPolygon(vertices, vertexCount, color);
      return this._graphics.endFill();
    };

    DebugDraw.prototype.DrawTransform = function(xf) {
      var p1, p2, p3;

      this._graphics.lineStyle(this._line_width, 0xFF0000);
      this._graphics.alpha = this._alpha;
      p1 = this._worldToScreen(xf.position);
      p2 = {
        x: xf.position.x + xf.R.col1.x,
        y: xf.position.y + xf.R.col1.y
      };
      p2 = this._worldToScreen(p2);
      p3 = {
        x: xf.position.x + xf.R.col2.x,
        y: xf.position.y + xf.R.col2.y
      };
      p3 = this._worldToScreen(p3);
      this._graphics.moveTo(p1.x, p1.y);
      this._graphics.lineTo(p2.x, p2.y);
      this._graphics.moveTo(p1.x, p1.y);
      return this._graphics.lineTo(p3.x, p3.y);
    };

    DebugDraw.prototype.GetAlpha = function() {
      return this._alpha;
    };

    DebugDraw.prototype.GetDrawScale = function() {
      return this._scale;
    };

    DebugDraw.prototype.GetFillAlpha = function() {
      return this._fill_alpha;
    };

    DebugDraw.prototype.GetLineThickness = function() {
      return this._line_width;
    };

    DebugDraw.prototype.SetAlpha = function(_alpha) {
      this._alpha = _alpha;
    };

    DebugDraw.prototype.SetDrawScale = function(_scale) {
      this._scale = _scale;
    };

    DebugDraw.prototype.SetLineThickness = function(_line_width) {
      this._line_width = _line_width;
    };

    return DebugDraw;

  })(b2Dynamics.b2DebugDraw);

  Paddle = (function() {
    Paddle.prototype.LENGTH = 75;

    Paddle.prototype.WIDTH = 10;

    Paddle.prototype.FORCE = 200;

    Paddle.prototype.MAX_VEL = 100;

    Paddle.prototype.TORQUE = 10;

    Paddle.prototype.MAX_SPIN = 50;

    Paddle.prototype.DAMPING_MOVE = 0;

    Paddle.prototype.DAMPING_STILL = 5;

    Paddle.prototype.buttons = null;

    function Paddle(game, x, start_y) {
      var b2_length, b2_width, b2_x, b2_y, bodyDef, fixDef, g, jointDef, t;

      this.game = game;
      if (start_y == null) {
        start_y = settings.HEIGHT / 2;
      }
      this.buttons = {
        up: false,
        down: false,
        left: false,
        right: false
      };
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, this.WIDTH, this.LENGTH);
      t = g.generateTexture();
      this.sprite = new PIXI.Sprite(t);
      this.sprite.anchor.x = 0.5;
      this.sprite.anchor.y = 0.5;
      this.game.game_stage.addChild(this.sprite);
      b2_width = this.WIDTH / settings.PPM;
      b2_length = this.LENGTH / settings.PPM;
      b2_x = x / settings.PPM;
      b2_y = start_y / settings.PPM;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_width / 2, b2_length / 2);
      this.paddle_body = this.game.world.CreateBody(bodyDef);
      this.paddle_body.CreateFixture(fixDef);
      fixDef.density = 1;
      fixDef.friction = 0.0;
      fixDef.restitution = 0.0;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(0.1, 0.1);
      this.anchor_body = this.game.world.CreateBody(bodyDef);
      this.anchor_body.CreateFixture(fixDef);
      jointDef = new b2Joints.b2PrismaticJointDef();
      jointDef.Initialize(this.game.top_boundary, this.anchor_body, new b2Vec2(b2_x, 0), new b2Vec2(0, 1));
      this.game.world.CreateJoint(jointDef);
      jointDef = new b2Joints.b2RevoluteJointDef();
      jointDef.Initialize(this.paddle_body, this.anchor_body, this.anchor_body.GetWorldCenter());
      this.game.world.CreateJoint(jointDef);
    }

    Paddle.prototype.position = function() {
      return this.paddle_body.GetPosition();
    };

    Paddle.prototype.update = function() {
      var body, dir, pos, spin, torque, vel;

      body = this.paddle_body;
      pos = body.GetPosition();
      vel = body.GetLinearVelocity();
      spin = body.GetAngularVelocity();
      dir = new b2Vec2(0, 0);
      if (this.buttons.up !== this.buttons.down) {
        if (this.buttons.up) {
          dir = new b2Vec2(0, -1);
        } else if (this.buttons.down) {
          dir = new b2Vec2(0, 1);
        }
      }
      if (this.buttons.up || this.buttons.down) {
        body.SetLinearDamping(this.DAMPING_MOVE);
      } else {
        body.SetLinearDamping(this.DAMPING_STILL);
      }
      dir.Multiply(this.FORCE);
      body.ApplyForce(dir, pos);
      if (Math.abs(vel.x) > this.MAX_VEL) {
        vel.x = (vel.x > 0 ? 1 : -1) * this.MAX_VEL;
        body.SetLinearVelocity(vel);
      }
      if (Math.abs(vel.y) > this.MAX_VEL) {
        vel.y = (vel.y > 0 ? 1 : -1) * this.MAX_VEL;
        body.SetLinearVelocity(vel);
      }
      torque = 0;
      if (this.buttons.left !== this.buttons.right) {
        if (this.buttons.left) {
          torque = -1;
        } else if (this.buttons.right) {
          torque = 1;
        }
      }
      torque *= this.TORQUE;
      body.ApplyTorque(torque);
      if (Math.abs(spin) > this.MAX_SPIN) {
        spin = (spin > 0 ? 1 : -1) * this.MAX_SPIN;
        return body.SetAngularVelocity(spin);
      }
    };

    Paddle.prototype.draw = function() {
      var pos;

      pos = this.position();
      this.sprite.position.x = pos.x * settings.PPM;
      return this.sprite.position.y = pos.y * settings.PPM;
    };

    Paddle.prototype.startUp = function() {
      return this.buttons.up = true;
    };

    Paddle.prototype.endUp = function() {
      return this.buttons.up = false;
    };

    Paddle.prototype.startDown = function() {
      return this.buttons.down = true;
    };

    Paddle.prototype.endDown = function() {
      return this.buttons.down = false;
    };

    Paddle.prototype.startLeft = function() {
      return this.buttons.left = true;
    };

    Paddle.prototype.endLeft = function() {
      return this.buttons.left = false;
    };

    Paddle.prototype.startRight = function() {
      return this.buttons.right = true;
    };

    Paddle.prototype.endRight = function() {
      return this.buttons.right = false;
    };

    return Paddle;

  })();

  Game = (function() {
    Game.prototype.states = {
      MENU: 0,
      GAME: 1,
      END: 2
    };

    Game.prototype.state = null;

    Game.prototype.left_paddle = null;

    Game.prototype.right_paddle = null;

    function Game(stage) {
      var b2_h, b2_w, b2_x, b2_y, bodyDef, cx, cy, debug_drawer, doSleep, fixDef, offset, style;

      this.stage = stage;
      this.hud_stage = new PIXI.DisplayObjectContainer();
      this.game_stage = new PIXI.DisplayObjectContainer();
      this.bg_stage = new PIXI.DisplayObjectContainer();
      this.stage.addChild(this.bg_stage);
      this.stage.addChild(this.game_stage);
      this.stage.addChild(this.hud_stage);
      this.hud_graphics = new PIXI.Graphics();
      this.hud_stage.addChild(this.hud_graphics);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.begin_text = new PIXI.Text("Press SPACE to begin", style);
      this.return_text = new PIXI.Text("Press SPACE to return to menu", style);
      cx = settings.WIDTH / 2;
      cy = settings.HEIGHT / 2;
      this.begin_text.position.x = Math.round(cx - this.begin_text.width / 2);
      this.begin_text.position.y = Math.round(cy - this.begin_text.height / 2);
      this.return_text.position.x = Math.round(cx - this.return_text.width / 2);
      this.return_text.position.y = Math.round(cy - this.return_text.height / 2);
      this.world = new b2Dynamics.b2World(new b2Vec2(0, 0), doSleep = false);
      if (settings.DEBUG_DRAW) {
        debug_drawer = new DebugDraw();
        debug_drawer.SetSprite(this.hud_graphics);
        debug_drawer.SetDrawScale(1);
        debug_drawer.SetAlpha(1);
        debug_drawer.SetFillAlpha(1);
        debug_drawer.SetLineThickness(1.0);
        debug_drawer.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit | b2DebugDraw.e_centerOfMassBit | b2DebugDraw.e_controllerBit | b2DebugDraw.e_pairBit | b2DebugDraw.e_aabbBit);
        this.world.SetDebugDraw(debug_drawer);
      }
      b2_w = settings.WIDTH / settings.PPM;
      b2_h = 1;
      offset = b2_h / 2;
      b2_x = b2_w / 2;
      b2_y = -offset;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_staticBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.top_boundary = this.world.CreateBody(bodyDef);
      this.top_boundary.CreateFixture(fixDef);
      bodyDef.position.x = b2_x;
      bodyDef.position.y = settings.HEIGHT / settings.PPM + offset;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.bottom_boundary = this.world.CreateBody(bodyDef);
      this.bottom_boundary.CreateFixture(fixDef);
      this.left_paddle = new Paddle(this, settings.PADDLE_X);
      this.right_paddle = new Paddle(this, settings.WIDTH - settings.PADDLE_X);
      this.gotoMenu();
    }

    Game.prototype.update = function() {
      this.left_paddle.update();
      this.right_paddle.update();
      this.world.Step(settings.BOX2D_TIME_STEP, settings.BOX2D_VI, settings.BOX2D_PI);
      return this.world.ClearForces();
    };

    Game.prototype.clear = function() {
      return this.hud_graphics.clear();
    };

    Game.prototype.draw = function() {
      this.left_paddle.draw();
      this.right_paddle.draw();
      if (settings.DEBUG_DRAW) {
        return this.world.DrawDebugData();
      }
    };

    Game.prototype.startGame = function() {
      this.state = this.states.GAME;
      return this.hud_stage.removeChild(this.begin_text);
    };

    Game.prototype.endGame = function() {
      this.state = this.states.END;
      return this.hud_stage.addChild(this.return_text);
    };

    Game.prototype.gotoMenu = function() {
      var _ref;

      this.state = this.states.MENU;
      this.hud_stage.addChild(this.begin_text);
      if (_ref = this.return_text, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        return this.hud_stage.removeChild(this.return_text);
      }
    };

    Game.prototype.onKeyDown = function(key_code) {
      var bindings;

      bindings = settings.BINDINGS;
      switch (key_code) {
        case bindings.P1_UP:
          return this.left_paddle.startUp();
        case bindings.P1_DOWN:
          return this.left_paddle.startDown();
        case bindings.P1_LEFT:
          return this.left_paddle.startLeft();
        case bindings.P1_RIGHT:
          return this.left_paddle.startRight();
        case bindings.P2_UP:
          return this.right_paddle.startUp();
        case bindings.P2_DOWN:
          return this.right_paddle.startDown();
        case bindings.P2_LEFT:
          return this.right_paddle.startLeft();
        case bindings.P2_RIGHT:
          return this.right_paddle.startRight();
        case bindings.START:
          switch (this.state) {
            case this.states.MENU:
              return this.startGame();
            case this.states.END:
              return this.gotoMenu();
            case this.states.GAME:
              return this.endGame();
          }
      }
    };

    Game.prototype.onKeyUp = function(key_code) {
      var bindings;

      bindings = settings.BINDINGS;
      switch (key_code) {
        case bindings.P1_UP:
          return this.left_paddle.endUp();
        case bindings.P1_DOWN:
          return this.left_paddle.endDown();
        case bindings.P1_LEFT:
          return this.left_paddle.endLeft();
        case bindings.P1_RIGHT:
          return this.left_paddle.endRight();
        case bindings.P2_UP:
          return this.right_paddle.endUp();
        case bindings.P2_DOWN:
          return this.right_paddle.endDown();
        case bindings.P2_LEFT:
          return this.right_paddle.endLeft();
        case bindings.P2_RIGHT:
          return this.right_paddle.endRight();
      }
    };

    Game.prototype.onMouseDown = function(button, screen_pos) {};

    Game.prototype.onMouseUp = function(button, screen_pos) {};

    Game.prototype.onMouseMove = function(screen_pos) {};

    Game.prototype.onMouseWheel = function(delta) {};

    return Game;

  })();

  $(function() {
    var DOM_LOADED;

    DOM_LOADED = true;
    return main();
  });

  W = settings.WIDTH;

  H = settings.HEIGHT;

  main = function() {
    var black, blurHandler, body, canvas, clear, clickHandler, container, contextMenuHandler, draw, event_catcher, focusHandler, game, keyDownListener, keyUpListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, queue, renderer, stage, update;

    body = $('body');
    container = $('<div>');
    container.css('margin-right', 'auto');
    container.css('margin-left', 'auto');
    container.css('width', "" + W + "px");
    body.append(container);
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(W, H);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    game = new Game(stage);
    onResize = function() {
      return log_input("resize");
    };
    keyDownListener = function(e) {
      log_input("key down:", e.keyCode);
      return game.onKeyDown(e.keyCode);
    };
    keyUpListener = function(e) {
      log_input("key up:", e.keyCode);
      return game.onKeyUp(e.keyCode);
    };
    onBeforeUnload = function(e) {
      return log_input("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      log_input("mouse:", x, y);
      return game.onMouseMove({
        x: x,
        y: y
      });
    };
    clickHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      return log_input("click:", x, y);
    };
    contextMenuHandler = function(e) {
      log_input("context menu");
      return false;
    };
    mouseDownHandler = function(e) {
      var x, y;

      log_input("mouse down");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseDown(e.button, {
        x: x,
        y: y
      });
    };
    mouseUpHandler = function(e) {
      var x, y;

      log_input("mouse up");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseUp(e.button, {
        x: x,
        y: y
      });
    };
    mouseOutHandler = function(e) {
      return log_input("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return log_input("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return log_input("focus");
    };
    blurHandler = function(e) {
      return log_input("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    document.body.addEventListener('keyup', keyUpListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.oncontextmenu = contextMenuHandler;
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      return game.update();
    };
    clear = function() {
      return game.clear();
    };
    draw = function() {
      game.draw();
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

  log_input = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (settings.PRINT_INPUT) {
      return console.log.apply(console, args);
    }
  };

}).call(this);
