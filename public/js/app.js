// Generated by CoffeeScript 1.6.2
(function() {
  var Ball, DebugDraw, Game, H, HardAI, NormalAI, Paddle, W, b2Collision, b2Common, b2Contacts, b2Controllers, b2DebugDraw, b2Dynamics, b2Joints, b2Math, b2Shapes, b2Vec2, log_input, main, settings,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  Ball = (function() {
    function Ball(game, sprite, fix_def) {
      this.game = game;
      this.sprite = sprite;
      this.fix_def = fix_def;
      this.body_def = new b2Dynamics.b2BodyDef();
      this.body_def.type = b2Dynamics.b2Body.b2_dynamicBody;
      this.body_def.bullet = true;
    }

    Ball.prototype.init = function(pos, vel) {
      var b2_x, b2_y, f;

      this.body = this.game.world.CreateBody(this.body_def);
      this.body.CreateFixture(this.fix_def);
      f = this.body.GetFixtureList().GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BALL;
      this.body.GetFixtureList().SetFilterData(f);
      b2_x = pos.x / settings.PPM;
      b2_y = pos.y / settings.PPM;
      pos = new b2Vec2(b2_x, b2_y);
      this.body.SetPosition(pos);
      vel = new b2Vec2(vel.x / settings.PPM, vel.y / settings.PPM);
      this.body.SetLinearVelocity(vel);
      return this.game.game_stage.addChild(this.sprite);
    };

    Ball.prototype.destroy = function() {
      var body;

      body = this.game.world.GetBodyList();
      while (body) {
        if (body === this.body) {
          this.game.world.DestroyBody(body);
        }
        body = body.GetNext();
      }
      return this.game.game_stage.removeChild(this.sprite);
    };

    Ball.prototype.update = function() {
      var a, angle, c, dif, f, mag, magnus_dir, magnus_force, magnus_unit, spin, target_angle, vel, x, y;

      vel = this.body.GetLinearVelocity();
      angle = Math.atan(vel.y / vel.x);
      a = settings.BALL.MAX_ANGLE / 180 * Math.PI;
      if (Math.abs(angle) > a) {
        target_angle = (angle > 0 ? 1 : -1) * a;
        dif = target_angle - angle;
        x = vel.x * Math.cos(dif) - vel.y * Math.sin(dif);
        y = vel.x * Math.sin(dif) + vel.y * Math.cos(dif);
        vel.x = x;
        vel.y = y;
      }
      if (Math.abs(vel.x) < settings.BALL.MIN_X_VEL) {
        vel.x = (vel.x > 0 ? 1 : -1) * settings.BALL.MIN_X_VEL;
        this.body.SetLinearVelocity(vel);
      }
      this.body.SetLinearVelocity(vel);
      spin = this.body.GetAngularVelocity();
      magnus_dir = {
        x: -vel.y,
        y: vel.x
      };
      if (spin > 0) {
        magnus_dir.x *= -1;
        magnus_dir.y *= -1;
      }
      mag = Math.sqrt(magnus_dir.x * magnus_dir.x + magnus_dir.y * magnus_dir.y);
      magnus_unit = {
        x: magnus_dir.x / mag,
        y: magnus_dir.y / mag
      };
      mag = spin * settings.BALL.MAGNUS_FORCE;
      magnus_force = new b2Vec2(magnus_unit.x * mag, magnus_unit.y * mag);
      this.body.ApplyForce(magnus_force, this.body.GetPosition());
      f = this.body.GetFixtureList().GetFilterData();
      c = settings.COLLISION_CATEGORY;
      if (vel.x > 0) {
        f.maskBits = c.BOUNDARY | c.PADDLE_R;
      } else {
        f.maskBits = c.BOUNDARY | c.PADDLE_L;
      }
      return this.body.GetFixtureList().SetFilterData(f);
    };

    Ball.prototype.draw = function() {
      var pos, rot;

      pos = this.body.GetPosition();
      rot = this.body.GetAngle();
      this.sprite.position.x = pos.x * settings.PPM;
      this.sprite.position.y = pos.y * settings.PPM;
      return this.sprite.rotation = rot;
    };

    Ball.prototype.position = function() {
      return this.body.GetPosition();
    };

    Ball.prototype.velocity = function() {
      return this.body.GetLinearVelocity();
    };

    Ball.prototype.angularVelocity = function() {
      return this.body.GetAngularVelocity();
    };

    return Ball;

  })();

  settings = {
    DEBUG: true,
    DEBUG_DRAW: false,
    PRINT_INPUT: false,
    WIDTH: 1000,
    HEIGHT: 500,
    AUDIO_PATH: "assets/snd/",
    SOUNDS: {
      PADDLE_CONTACT: {
        ID: "Paddle contact",
        SRC: "paddle_contact.ogg"
      },
      SCORE: {
        ID: "Score",
        SRC: "score.ogg"
      },
      START_TIMER: {
        ID: "Start timer",
        SRC: "start_timer.ogg"
      },
      START_BUZZER: {
        ID: "Start buzzer",
        SRC: "start_buzzer.ogg"
      },
      END_TIMER: {
        ID: "End timer",
        SRC: "end_timer.ogg"
      },
      END_BUZZER: {
        ID: "End buzzer",
        SRC: "end_buzzer.ogg"
      }
    },
    PADDLE: {
      X: 20,
      LENGTH: 75,
      WIDTH: 10,
      MOVE_FORCE: 80,
      MAX_VEL: 60,
      ANGLE: 20,
      DAMPING_MOVE: 0,
      DAMPING_STILL: 10
    },
    BALL: {
      SIZE: 15,
      MIN_X_VEL: 20,
      MAX_ANGLE: 60,
      MAGNUS_FORCE: .05
    },
    PPM: 30,
    BOX2D_TIME_STEP: 1 / 60,
    BOX2D_VI: 10,
    BOX2D_PI: 10,
    BINDINGS: {
      P1_UP: 87,
      P1_DOWN: 83,
      P1_LEFT: 65,
      P1_RIGHT: 68,
      P2_UP: 38,
      P2_DOWN: 40,
      P2_LEFT: 37,
      P2_RIGHT: 39,
      START: 32,
      END: 27
    },
    COLLISION_CATEGORY: {
      PADDLE_L: 0x0001,
      PADDLE_R: 0x0002,
      BALL: 0x0004,
      BOUNDARY: 0x0008
    }
  };

  b2Common = Box2D.Common;

  b2Math = Box2D.Common.Math;

  b2Vec2 = b2Math.b2Vec2;

  b2Collision = Box2D.Collision;

  b2Shapes = Box2D.Collision.Shapes;

  b2Dynamics = Box2D.Dynamics;

  b2Contacts = Box2D.Dynamics.Contacts;

  b2Controllers = Box2D.Dynamics.Controllers;

  b2Joints = Box2D.Dynamics.Joints;

  b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  DebugDraw = (function(_super) {
    __extends(DebugDraw, _super);

    function DebugDraw() {
      this._line_width = 1;
      this._alpha = 0.5;
      this._fill_alpha = 0.5;
      this.m_sprite = {
        graphics: {
          clear: function() {}
        }
      };
    }

    DebugDraw.prototype._worldToScreen = function(pos) {
      return {
        x: pos.x * settings.PPM,
        y: pos.y * settings.PPM
      };
    };

    DebugDraw.prototype.SetSprite = function(_graphics) {
      this._graphics = _graphics;
    };

    DebugDraw.prototype.GetSprite = function() {
      return this._graphics;
    };

    DebugDraw.prototype.DrawCircle = function(center, radius, color) {
      this._graphics.alpha = this._alpha;
      this._graphics.lineStyle(this._line_width, color.color);
      center = this._worldToScreen(center);
      return this._graphics.drawCircle(center.x, center.y, radius * settings.PPM);
    };

    DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
      var v, v0, _i, _len, _ref;

      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      v0 = vertices[0];
      v0 = this._worldToScreen(v0);
      this._graphics.moveTo(v0.x, v0.y);
      _ref = vertices.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v = this._worldToScreen(v);
        this._graphics.lineTo(v.x, v.y);
      }
      return this._graphics.lineTo(v0.x, v0.y);
    };

    DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
      this._graphics.lineStyle(this._line_width, color.color);
      this._graphics.alpha = this._alpha;
      p1 = this._worldToScreen(p1);
      p2 = this._worldToScreen(p2);
      this._graphics.moveTo(p1.x, p1.y);
      return this._graphics.lineTo(p2.x, p2.y);
    };

    DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
      var edge;

      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawCircle(center, radius, color);
      this._graphics.endFill();
      axis = axis.Copy();
      axis.Normalize();
      axis.Multiply(radius);
      edge = center.Copy();
      edge.Add(axis);
      return this.DrawSegment(center, edge, color);
    };

    DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
      this._graphics.beginFill(color.color);
      this._graphics.fillAlpha = this._fill_alpha;
      this.DrawPolygon(vertices, vertexCount, color);
      return this._graphics.endFill();
    };

    DebugDraw.prototype.DrawTransform = function(xf) {
      var p1, p2, p3;

      this._graphics.lineStyle(this._line_width, 0xFF0000);
      this._graphics.alpha = this._alpha;
      p1 = this._worldToScreen(xf.position);
      p2 = {
        x: xf.position.x + xf.R.col1.x,
        y: xf.position.y + xf.R.col1.y
      };
      p2 = this._worldToScreen(p2);
      p3 = {
        x: xf.position.x + xf.R.col2.x,
        y: xf.position.y + xf.R.col2.y
      };
      p3 = this._worldToScreen(p3);
      this._graphics.moveTo(p1.x, p1.y);
      this._graphics.lineTo(p2.x, p2.y);
      this._graphics.moveTo(p1.x, p1.y);
      return this._graphics.lineTo(p3.x, p3.y);
    };

    DebugDraw.prototype.GetAlpha = function() {
      return this._alpha;
    };

    DebugDraw.prototype.GetDrawScale = function() {
      return this._scale;
    };

    DebugDraw.prototype.GetFillAlpha = function() {
      return this._fill_alpha;
    };

    DebugDraw.prototype.GetLineThickness = function() {
      return this._line_width;
    };

    DebugDraw.prototype.SetAlpha = function(_alpha) {
      this._alpha = _alpha;
    };

    DebugDraw.prototype.SetDrawScale = function(_scale) {
      this._scale = _scale;
    };

    DebugDraw.prototype.SetLineThickness = function(_line_width) {
      this._line_width = _line_width;
    };

    return DebugDraw;

  })(b2Dynamics.b2DebugDraw);

  HardAI = (function() {
    HardAI.prototype._in_range = false;

    function HardAI(game) {
      this.game = game;
    }

    HardAI.prototype.update = function() {
      var ball, ball_pos, ball_vel, h, padding, paddle, paddle_pos, r, range, y;

      paddle = this.game.right_paddle;
      ball = this.game.ball;
      paddle_pos = paddle.position();
      ball_pos = ball.position();
      ball_vel = ball.velocity();
      range = 5.0;
      if (ball_vel.x > 0) {
        y = this._getExpectedY(ball_pos, ball_vel);
        h = settings.HEIGHT / settings.PPM;
        while (!((0 <= y && y <= h))) {
          if (y < 0) {
            y = -y;
          } else if (y > h) {
            y = 2 * h - y;
          }
        }
        padding = Math.random() * 3.0 + 0.5;
        if (y > paddle_pos.y + padding) {
          paddle.endUp();
          paddle.startDown();
        } else if (y < paddle_pos.y - padding) {
          paddle.endDown();
          paddle.startUp();
        } else {
          paddle.endUp();
          paddle.endDown();
        }
      }
      padding = Math.random() * range - 1.5;
      if (ball_pos.x > paddle_pos.x - padding && !this._in_range) {
        this._in_range = true;
        r = Math.random();
        if (r < 0.3) {
          paddle.endLeft();
          return paddle.startRight();
        } else if (r < 0.6) {
          paddle.endRight();
          return paddle.startLeft();
        } else {
          paddle.endLeft();
          return paddle.endRight();
        }
      } else if (ball_pos.x < paddle_pos.x - range && this._in_range) {
        this._in_range = false;
        paddle.endLeft();
        return paddle.endRight();
      }
    };

    HardAI.prototype._getExpectedY = function(pos, vel) {
      var dir, p, s;

      dir = vel.Copy();
      dir.Normalize();
      p = dir.Copy();
      s = 1;
      p.Multiply(s);
      p.Add(pos);
      while (p.x < (settings.WIDTH / settings.PPM)) {
        p = dir.Copy();
        s += 0.1;
        p.Multiply(s);
        p.Add(pos);
      }
      return p.y;
    };

    return HardAI;

  })();

  NormalAI = (function() {
    NormalAI.prototype._in_range = false;

    function NormalAI(game) {
      this.game = game;
    }

    NormalAI.prototype.update = function() {
      var ball, ball_pos, ball_vel, padding, paddle, paddle_pos, r, range;

      paddle = this.game.right_paddle;
      ball = this.game.ball;
      paddle_pos = paddle.position();
      ball_pos = ball.position();
      ball_vel = ball.velocity();
      range = 5.0;
      if (ball_vel.x > 0 || ball_pos.x > paddle_pos.x - range) {
        padding = Math.random() * 3.5 + 0.8;
        if (ball_pos.y > paddle_pos.y + padding) {
          paddle.endUp();
          paddle.startDown();
        } else if (ball_pos.y < paddle_pos.y - padding) {
          paddle.endDown();
          paddle.startUp();
        } else {
          paddle.endUp();
          paddle.endDown();
        }
      }
      padding = Math.random() * range - 1.5;
      if (ball_pos.x > paddle_pos.x - padding && !this._in_range) {
        this._in_range = true;
        r = Math.random();
        if (r < 0.3) {
          paddle.endLeft();
          return paddle.startRight();
        } else if (r < 0.6) {
          paddle.endRight();
          return paddle.startLeft();
        } else {
          paddle.endLeft();
          return paddle.endRight();
        }
      } else if (ball_pos.x < paddle_pos.x - range && this._in_range) {
        this._in_range = false;
        paddle.endLeft();
        return paddle.endRight();
      }
    };

    return NormalAI;

  })();

  Paddle = (function() {
    Paddle.prototype.buttons = null;

    function Paddle(game, x, start_y) {
      var b2_length, b2_width, b2_x, b2_y, bodyDef, f, fix, fixDef, g, jointDef, t;

      this.game = game;
      if (start_y == null) {
        start_y = settings.HEIGHT / 2;
      }
      this.buttons = {
        up: false,
        down: false,
        left: false,
        right: false
      };
      g = new PIXI.Graphics();
      g.lineStyle(2, 0xFFFFFF);
      g.drawRect(0, 0, settings.PADDLE.WIDTH, settings.PADDLE.LENGTH);
      t = g.generateTexture();
      this.sprite = new PIXI.Sprite(t);
      this.sprite.anchor.x = 0.5;
      this.sprite.anchor.y = 0.5;
      this.game.game_stage.addChild(this.sprite);
      b2_width = settings.PADDLE.WIDTH / settings.PPM;
      b2_length = settings.PADDLE.LENGTH / settings.PPM;
      b2_x = x / settings.PPM;
      b2_y = start_y / settings.PPM;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_dynamicBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      bodyDef.fixedRotation = true;
      bodyDef.bullet = true;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_width / 2, b2_length / 2);
      this.paddle_body = this.game.world.CreateBody(bodyDef);
      fix = this.paddle_body.CreateFixture(fixDef);
      f = fix.GetFilterData();
      if (x < settings.WIDTH / 2) {
        f.categoryBits = settings.COLLISION_CATEGORY.PADDLE_L;
      } else {
        f.categoryBits = settings.COLLISION_CATEGORY.PADDLE_R;
      }
      fix.SetFilterData(f);
      fixDef.density = 1;
      fixDef.friction = 0.0;
      fixDef.restitution = 0.0;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(0.1, 0.1);
      bodyDef.fixedRotation = false;
      this.anchor_body = this.game.world.CreateBody(bodyDef);
      fix = this.anchor_body.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = 0;
      fix.SetFilterData(f);
      jointDef = new b2Joints.b2PrismaticJointDef();
      jointDef.Initialize(this.game.top_boundary, this.anchor_body, new b2Vec2(b2_x, 0), new b2Vec2(0, 1));
      this.game.world.CreateJoint(jointDef);
      jointDef = new b2Joints.b2RevoluteJointDef();
      jointDef.Initialize(this.paddle_body, this.anchor_body, this.anchor_body.GetWorldCenter());
      this.game.world.CreateJoint(jointDef);
    }

    Paddle.prototype.position = function() {
      return this.paddle_body.GetPosition();
    };

    Paddle.prototype.destroy = function() {
      var body;

      body = this.game.world.GetBodyList();
      while (body) {
        if (body === this.anchor_body || body === this.paddle_body) {
          this.game.world.DestroyBody(body);
        }
        body = body.GetNext();
      }
      return this.game.game_stage.removeChild(this.sprite);
    };

    Paddle.prototype.update = function() {
      var body, dir, pos, spin, vel;

      body = this.paddle_body;
      pos = body.GetPosition();
      vel = body.GetLinearVelocity();
      spin = body.GetAngularVelocity();
      dir = new b2Vec2(0, 0);
      if (this.buttons.up !== this.buttons.down) {
        if (this.buttons.up) {
          dir = new b2Vec2(0, -1);
        } else if (this.buttons.down) {
          dir = new b2Vec2(0, 1);
        }
      }
      if (this.buttons.up || this.buttons.down) {
        body.SetLinearDamping(settings.PADDLE.DAMPING_MOVE);
      } else {
        body.SetLinearDamping(settings.PADDLE.DAMPING_STILL);
      }
      dir.Multiply(settings.PADDLE.MOVE_FORCE);
      body.ApplyForce(dir, pos);
      if (Math.abs(vel.x) > settings.PADDLE.MAX_VEL) {
        vel.x = (vel.x > 0 ? 1 : -1) * settings.PADDLE.MAX_VEL;
        body.SetLinearVelocity(vel);
      }
      if (Math.abs(vel.y) > settings.PADDLE.MAX_VEL) {
        vel.y = (vel.y > 0 ? 1 : -1) * settings.PADDLE.MAX_VEL;
        body.SetLinearVelocity(vel);
      }
      if (this.buttons.left !== this.buttons.right) {
        if (this.buttons.left) {
          body.SetAngle(-Math.PI / 180 * settings.PADDLE.ANGLE);
        } else if (this.buttons.right) {
          body.SetAngle(Math.PI / 180 * settings.PADDLE.ANGLE);
        }
      }
      if (!this.buttons.left && !this.buttons.right) {
        return body.SetAngle(0);
      }
    };

    Paddle.prototype.draw = function() {
      var pos, rot;

      pos = this.position();
      this.sprite.position.x = pos.x * settings.PPM;
      this.sprite.position.y = pos.y * settings.PPM;
      rot = this.paddle_body.GetAngle();
      return this.sprite.rotation = rot;
    };

    Paddle.prototype.startUp = function() {
      return this.buttons.up = true;
    };

    Paddle.prototype.endUp = function() {
      return this.buttons.up = false;
    };

    Paddle.prototype.startDown = function() {
      return this.buttons.down = true;
    };

    Paddle.prototype.endDown = function() {
      return this.buttons.down = false;
    };

    Paddle.prototype.startLeft = function() {
      return this.buttons.left = true;
    };

    Paddle.prototype.endLeft = function() {
      return this.buttons.left = false;
    };

    Paddle.prototype.startRight = function() {
      return this.buttons.right = true;
    };

    Paddle.prototype.endRight = function() {
      return this.buttons.right = false;
    };

    return Paddle;

  })();

  Game = (function() {
    Game.prototype.states = {
      MENU: 0,
      COUNT_DOWN: 1,
      GAME: 2,
      END: 3
    };

    Game.prototype.state = null;

    Game.prototype.left_paddle = null;

    Game.prototype.right_paddle = null;

    Game.prototype.ball = null;

    Game.prototype.time = 0;

    Game.prototype.time_limit = 60 * 2;

    Game.prototype.left_score = 0;

    Game.prototype.right_score = 0;

    Game.prototype.play_sfx = true;

    Game.prototype.ball_type = 0;

    Game.prototype.balls = [];

    Game.prototype._fade_time = 1;

    Game.prototype._start_time = 1;

    Game.prototype._loop_time = 0;

    Game.prototype._count_down = 3;

    Game.prototype._player2_type = "human";

    Game.prototype._normal_ai = null;

    Game.prototype._hard_ai = null;

    Game.prototype._can_score_l = true;

    Game.prototype._can_score_r = true;

    Game.prototype._wasd_1 = true;

    Game.prototype.GRAD_TIME = 20;

    Game.prototype.TIME_TEXT_SIZE = 50;

    function Game(stage) {
      var ai_hard, ai_hard_selected, ai_norm, ai_norm_selected, b2_h, b2_radius, b2_w, b2_x, b2_y, ball_buttons, bodyDef, c, count, cx, cy, debug_drawer, doSleep, f, fix, fixDef, fix_def, g, h, human, human_selected, margin, offset, padding, rt, sfx_off, sfx_off_hover, sfx_on, sfx_on_hover, size, sprite, stat_y, style, swap, swap_selected, t, w, x, y, _i, _lockText, _polyButton,
        _this = this;

      this.stage = stage;
      this.hud_stage = new PIXI.DisplayObjectContainer();
      this.game_stage = new PIXI.DisplayObjectContainer();
      this.bg_stage = new PIXI.DisplayObjectContainer();
      this.stage.addChild(this.bg_stage);
      this.stage.addChild(this.game_stage);
      this.stage.addChild(this.hud_stage);
      this.hud_graphics = new PIXI.Graphics();
      this.hud_stage.addChild(this.hud_graphics);
      cx = settings.WIDTH / 2;
      cy = settings.HEIGHT / 2;
      style = {
        font: "100px Arial",
        fill: "#FFFFFF"
      };
      this.title_text = new PIXI.Text("Ping", style);
      this.title_text.position.x = cx - this.title_text.width / 2;
      this.title_text.position.y = cy / 3;
      stat_y = Math.round(settings.HEIGHT * .65);
      padding = 15;
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.h_stat_text = new PIXI.Text("Human", style);
      this.h_stat_text.position.x = Math.round(.25 * cx + cx - this.h_stat_text.width / 2);
      this.h_stat_text.position.y = stat_y;
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.nai_stat_text = new PIXI.Text("Normal AI", style);
      this.nai_stat_text.position.x = Math.round(.5 * cx + cx - this.nai_stat_text.width / 2);
      this.nai_stat_text.position.y = stat_y;
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.hai_stat_text = new PIXI.Text("Hard AI", style);
      this.hai_stat_text.position.x = Math.round(.75 * cx + cx - this.hai_stat_text.width / 2);
      this.hai_stat_text.position.y = stat_y;
      style = {
        font: "10px Arial",
        fill: "#FFFFFF"
      };
      this.h_wins_text = new PIXI.Text("Wins:", style);
      this.h_wins_text.position.x = this.h_stat_text.position.x;
      this.h_wins_text.position.y = this.h_stat_text.position.y + padding + 5;
      this.h_losses_text = new PIXI.Text("Loses:", style);
      this.h_losses_text.position.x = this.h_stat_text.position.x;
      this.h_losses_text.position.y = this.h_wins_text.position.y + padding;
      this.h_ties_text = new PIXI.Text("Ties:", style);
      this.h_ties_text.position.x = this.h_stat_text.position.x;
      this.h_ties_text.position.y = this.h_losses_text.position.y + padding;
      this.h_best_text = new PIXI.Text("Best:", style);
      this.h_best_text.position.x = this.h_stat_text.position.x;
      this.h_best_text.position.y = this.h_ties_text.position.y + padding;
      this.h_total1_text = new PIXI.Text("Total:", style);
      this.h_total1_text.position.x = this.h_stat_text.position.x;
      this.h_total1_text.position.y = this.h_best_text.position.y + padding;
      this.nai_wins_text = new PIXI.Text("Wins:", style);
      this.nai_wins_text.position.x = this.nai_stat_text.position.x;
      this.nai_wins_text.position.y = this.nai_stat_text.position.y + padding + 5;
      this.nai_losses_text = new PIXI.Text("Loses:", style);
      this.nai_losses_text.position.x = this.nai_stat_text.position.x;
      this.nai_losses_text.position.y = this.nai_wins_text.position.y + padding;
      this.nai_ties_text = new PIXI.Text("Ties:", style);
      this.nai_ties_text.position.x = this.nai_stat_text.position.x;
      this.nai_ties_text.position.y = this.nai_losses_text.position.y + padding;
      this.nai_best_text = new PIXI.Text("Best:", style);
      this.nai_best_text.position.x = this.nai_stat_text.position.x;
      this.nai_best_text.position.y = this.nai_ties_text.position.y + padding;
      this.nai_total1_text = new PIXI.Text("Total:", style);
      this.nai_total1_text.position.x = this.nai_stat_text.position.x;
      this.nai_total1_text.position.y = this.nai_best_text.position.y + padding;
      this.hai_wins_text = new PIXI.Text("Wins:", style);
      this.hai_wins_text.position.x = this.hai_stat_text.position.x;
      this.hai_wins_text.position.y = this.hai_stat_text.position.y + padding + 5;
      this.hai_losses_text = new PIXI.Text("Loses:", style);
      this.hai_losses_text.position.x = this.hai_stat_text.position.x;
      this.hai_losses_text.position.y = this.hai_wins_text.position.y + padding;
      this.hai_ties_text = new PIXI.Text("Ties:", style);
      this.hai_ties_text.position.x = this.hai_stat_text.position.x;
      this.hai_ties_text.position.y = this.hai_losses_text.position.y + padding;
      this.hai_best_text = new PIXI.Text("Best:", style);
      this.hai_best_text.position.x = this.hai_stat_text.position.x;
      this.hai_best_text.position.y = this.hai_ties_text.position.y + padding;
      this.hai_total1_text = new PIXI.Text("Total:", style);
      this.hai_total1_text.position.x = this.hai_stat_text.position.x;
      this.hai_total1_text.position.y = this.hai_best_text.position.y + padding;
      style = {
        font: "50px Arial",
        fill: "#FFFFFF"
      };
      this.victor_text = new PIXI.Text("Player 1 Wins!", style);
      this.victor_text.position.x = cx - this.victor_text.width / 2;
      this.victor_text.position.y = cy / 3;
      this.countdown_text = new PIXI.Text("3", style);
      this.countdown_text.position.x = cx - this.countdown_text.width / 2;
      this.countdown_text.position.y = cy / 3;
      style = {
        font: "20px Arial",
        fill: "#FFFFFF"
      };
      this.player1_text = new PIXI.Text("Player 1", style);
      this.player1_text.position.x = cx / 3 - this.player1_text.width / 2;
      this.player1_text.position.y = cy / 2;
      this.player2_text = new PIXI.Text("Player 2", style);
      this.player2_text.position.x = settings.WIDTH - cx / 3 - this.player2_text.width / 2;
      this.player2_text.position.y = cy / 2;
      this.controls1 = new PIXI.Sprite.fromImage("assets/img/wasd.png");
      this.controls1.position.x = Math.round(cx / 4);
      this.controls1.position.y = Math.round(cy * 0.65);
      this.controls2 = new PIXI.Sprite.fromImage("assets/img/arrows.png");
      this.controls2.position.x = Math.round(settings.WIDTH - cx * 0.6);
      this.controls2.position.y = Math.round(cy * 0.65);
      w = 106;
      h = 25;
      rt = new PIXI.RenderTexture(w + 1, h + 1);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, w, h);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("Swap Controls", style);
      t.position.x = w / 2 - t.width / 2;
      t.position.y = h / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      swap = rt;
      rt = new PIXI.RenderTexture(w + 1, h + 1);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, w, h);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("Swap Controls", style);
      t.position.x = w / 2 - t.width / 2;
      t.position.y = h / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      swap_selected = rt;
      this.swap_box = new PIXI.Sprite(swap);
      this.swap_box.interactive = true;
      this.swap_box.hitArea = new PIXI.Rectangle(0, 0, w, h);
      this.swap_box.mouseover = function(data) {
        return this.setTexture(swap_selected);
      };
      this.swap_box.mouseout = function(data) {
        return this.setTexture(swap);
      };
      this.swap_box.click = function(data) {
        return _this._swapControls();
      };
      x = cx / 4 - 13;
      y = cy * 0.9;
      this.swap_box.x = Math.round(x);
      this.swap_box.y = Math.round(y);
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("Human", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      human = rt;
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("Human", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      human_selected = rt;
      this.human_box = new PIXI.Sprite(human_selected);
      this.human_box.interactive = true;
      this.human_box.hitArea = new PIXI.Rectangle(0, 0, 75, 25);
      this.human_box.selected = true;
      this.human_box.setSelected = function(val) {
        if (val !== this.selected) {
          if (val) {
            this.selected = true;
            return this.setTexture(human_selected);
          } else {
            this.selected = false;
            return this.setTexture(human);
          }
        }
      };
      this.human_box.mouseover = function(data) {
        return this.setTexture(human_selected);
      };
      this.human_box.mouseout = function(data) {
        if (!this.selected) {
          return this.setTexture(human);
        }
      };
      this.human_box.click = function(data) {
        _this.ai_norm_box.setSelected(false);
        _this.ai_hard_box.setSelected(false);
        data.target.setSelected(true);
        return _this._onSelectHuman();
      };
      x = settings.WIDTH - cx / 3;
      y = cy * 0.7;
      this.human_box.x = Math.round(x - this.human_box.width / 2);
      this.human_box.y = Math.round(y - this.human_box.height / 2);
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("Normal AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_norm = rt;
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("Normal AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_norm_selected = rt;
      this.ai_norm_box = new PIXI.Sprite(ai_norm);
      this.ai_norm_box.interactive = true;
      this.ai_norm_box.hitArea = new PIXI.Rectangle(0, 0, 75, 25);
      this.ai_norm_box.selected = false;
      this.ai_norm_box.setSelected = function(val) {
        if (val !== this.selected) {
          if (val) {
            this.selected = true;
            return this.setTexture(ai_norm_selected);
          } else {
            this.selected = false;
            return this.setTexture(ai_norm);
          }
        }
      };
      this.ai_norm_box.mouseover = function(data) {
        return this.setTexture(ai_norm_selected);
      };
      this.ai_norm_box.mouseout = function(data) {
        if (!this.selected) {
          return this.setTexture(ai_norm);
        }
      };
      this.ai_norm_box.click = function(data) {
        _this.human_box.setSelected(false);
        _this.ai_hard_box.setSelected(false);
        data.target.setSelected(true);
        return _this._onSelectNormAI();
      };
      x = settings.WIDTH - cx / 3;
      y = cy * 0.7 + 25 + 10;
      this.ai_norm_box.x = Math.round(x - this.ai_norm_box.width / 2);
      this.ai_norm_box.y = Math.round(y - this.ai_norm_box.height / 2);
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("Hard AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_hard = rt;
      rt = new PIXI.RenderTexture(76, 26);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, 75, 25);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("Hard AI", style);
      t.position.x = 75 / 2 - t.width / 2;
      t.position.y = 25 / 2 - t.height / 2;
      c.addChild(t);
      rt.render(c);
      ai_hard_selected = rt;
      this.ai_hard_box = new PIXI.Sprite(ai_hard);
      this.ai_hard_box.interactive = true;
      this.ai_hard_box.hitArea = new PIXI.Rectangle(0, 0, 75, 25);
      this.ai_hard_box.selected = false;
      this.ai_hard_box.setSelected = function(val) {
        if (val !== this.selected) {
          if (val) {
            this.selected = true;
            return this.setTexture(ai_hard_selected);
          } else {
            this.selected = false;
            return this.setTexture(ai_hard);
          }
        }
      };
      this.ai_hard_box.mouseover = function(data) {
        return this.setTexture(ai_hard_selected);
      };
      this.ai_hard_box.mouseout = function(data) {
        if (!this.selected) {
          return this.setTexture(ai_hard);
        }
      };
      this.ai_hard_box.click = function(data) {
        _this.human_box.setSelected(false);
        _this.ai_norm_box.setSelected(false);
        data.target.setSelected(true);
        return _this._onSelectHardAI();
      };
      x = settings.WIDTH - cx / 3;
      y = cy * 0.7 + 2 * (25 + 10);
      this.ai_hard_box.x = Math.round(x - this.ai_hard_box.width / 2);
      this.ai_hard_box.y = Math.round(y - this.ai_hard_box.height / 2);
      w = 75;
      h = 25;
      rt = new PIXI.RenderTexture(w + 1, h + 1);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, w, h);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("SFX: ON", style);
      t.position.x = Math.round(w / 2 - t.width / 2);
      t.position.y = Math.round(h / 2 - t.height / 2);
      c.addChild(t);
      rt.render(c);
      sfx_on = rt;
      rt = new PIXI.RenderTexture(w + 1, h + 1);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, w, h);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("SFX: ON", style);
      t.position.x = Math.round(w / 2 - t.width / 2);
      t.position.y = Math.round(h / 2 - t.height / 2);
      c.addChild(t);
      rt.render(c);
      sfx_on_hover = rt;
      rt = new PIXI.RenderTexture(w + 1, h + 1);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.lineStyle(1, 0xFFFFFF);
      g.drawRect(0, 0, w, h);
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      t = new PIXI.Text("SFX: OFF", style);
      t.position.x = Math.round(w / 2 - t.width / 2);
      t.position.y = Math.round(h / 2 - t.height / 2);
      c.addChild(t);
      rt.render(c);
      sfx_off = rt;
      rt = new PIXI.RenderTexture(w + 1, h + 1);
      c = new PIXI.DisplayObjectContainer();
      g = new PIXI.Graphics();
      g.beginFill(0xFFFFFF);
      g.drawRect(0, 0, w, h);
      g.endFill();
      c.addChild(g);
      style = {
        font: "15px Arial",
        fill: "#000000"
      };
      t = new PIXI.Text("SFX: OFF", style);
      t.position.x = Math.round(w / 2 - t.width / 2);
      t.position.y = Math.round(h / 2 - t.height / 2);
      c.addChild(t);
      rt.render(c);
      sfx_off_hover = rt;
      this.sfx_box = new PIXI.Sprite(sfx_on);
      this.sfx_box.interactive = true;
      this.sfx_box.hitArea = new PIXI.Rectangle(0, 0, w, h);
      this.sfx_box.mouseover = function(data) {
        if (_this.play_sfx) {
          return data.target.setTexture(sfx_on_hover);
        } else {
          return data.target.setTexture(sfx_off_hover);
        }
      };
      this.sfx_box.mouseout = function(data) {
        if (_this.play_sfx) {
          return data.target.setTexture(sfx_on);
        } else {
          return data.target.setTexture(sfx_off);
        }
      };
      this.sfx_box.click = function(data) {
        _this.play_sfx = !_this.play_sfx;
        if (_this.play_sfx) {
          return data.target.setTexture(sfx_on_hover);
        } else {
          return data.target.setTexture(sfx_off_hover);
        }
      };
      this.sfx_box.x = settings.WIDTH - w - 10;
      this.sfx_box.y = settings.HEIGHT - h - 10;
      style = {
        font: "15px Arial",
        fill: "#FFFFFF"
      };
      this.begin_text = new PIXI.Text("Press SPACE to begin", style);
      this.return_text = new PIXI.Text("Press SPACE to return to menu", style);
      this.begin_text.position.x = Math.round(cx - this.begin_text.width / 2);
      this.begin_text.position.y = Math.round(cy - this.begin_text.height / 2);
      this.return_text.position.x = Math.round(cx - this.return_text.width / 2);
      this.return_text.position.y = Math.round(cy - this.return_text.height / 2);
      style = {
        font: "10px Arial",
        fill: "#FFFFFF"
      };
      this.quit_text = new PIXI.Text("Press ESC to quit", style);
      this.quit_text.position.x = Math.round(settings.WIDTH / 2 - this.quit_text.width / 2);
      this.quit_text.position.y = 0;
      style = {
        font: "" + this.TIME_TEXT_SIZE + "px Arial",
        fill: "#FFFFFF"
      };
      this.time_text = new PIXI.Text("000", style);
      this.time_text.anchor.x = 0.5;
      this.time_text.anchor.y = 0.5;
      this.time_text.position.x = settings.WIDTH / 2;
      this.time_text.position.y = 10 + this.time_text.height / 2;
      this.time_text.scale.x = 0.5;
      this.time_text.scale.y = 0.5;
      style = {
        font: "30px Arial",
        fill: "#FFFFFF"
      };
      this.left_score_text = new PIXI.Text("", style);
      this.left_score_text.position.x = settings.WIDTH / 4;
      this.left_score_text.position.y = 10;
      this.right_score_text = new PIXI.Text("", style);
      this.right_score_text.position.x = 3 * settings.WIDTH / 4;
      this.right_score_text.position.y = 10;
      g = new PIXI.Graphics();
      count = 30;
      for (x = _i = 0; 0 <= count ? _i < count : _i > count; x = 0 <= count ? ++_i : --_i) {
        g.lineStyle(1, 0xFFFFFF, 1 - (x / count));
        g.moveTo(x, 0);
        g.lineTo(x, settings.HEIGHT);
      }
      this.score_grad = new PIXI.Sprite(g.generateTexture());
      this.score_grad.anchor.x = 11 / this.score_grad.width;
      this.score_grad.anchor.y = 11 / this.score_grad.height;
      padding = 10;
      margin = 10;
      ball_buttons = [];
      _polyButton = function(x, y, size, sides) {
        var button, button_box, button_selected, i, poly, r;

        if (sides > 2) {
          poly = _this._getPolygon(sides, size / settings.PPM);
        } else {
          r = size;
        }
        size = (size + padding) * 2;
        rt = new PIXI.RenderTexture(size + 1, size + 1);
        c = new PIXI.DisplayObjectContainer();
        g = new PIXI.Graphics();
        g.lineStyle(1, 0xFFFFFF);
        g.drawRect(0, 0, size, size);
        if (sides > 2) {
          _this._drawPolygon(poly, g, size / 2, size / 2);
        } else {
          g.lineStyle(2, 0xFFFFFF);
          g.drawCircle(size / 2, size / 2, r);
          g.moveTo(size / 2, size / 2);
          g.lineTo(size / 2 + r, size / 2);
        }
        c.addChild(g);
        rt.render(c);
        button = rt;
        rt = new PIXI.RenderTexture(size + 1, size + 1);
        c = new PIXI.DisplayObjectContainer();
        g = new PIXI.Graphics();
        g.beginFill(0xFFFFFF);
        g.drawRect(0, 0, size, size);
        g.endFill();
        if (sides > 2) {
          _this._drawPolygon(poly, g, size / 2, size / 2, 0x000000);
        } else {
          g.lineStyle(2, 0x000000);
          g.drawCircle(size / 2, size / 2, r);
          g.moveTo(size / 2, size / 2);
          g.lineTo(size / 2 + r, size / 2);
        }
        c.addChild(g);
        rt.render(c);
        button_selected = rt;
        button_box = new PIXI.Sprite(button);
        button_box.interactive = true;
        button_box.hitArea = new PIXI.Rectangle(0, 0, size, size);
        button_box.selected = false;
        button_box.setSelected = function(val) {
          if (val !== this.selected) {
            if (val) {
              this.selected = true;
              return this.setTexture(button_selected);
            } else {
              this.selected = false;
              return this.setTexture(button);
            }
          }
        };
        button_box.mouseover = function(data) {
          return this.setTexture(button_selected);
        };
        button_box.mouseout = function(data) {
          if (!this.selected) {
            return this.setTexture(button);
          }
        };
        i = ball_buttons.length;
        button_box.click = function(data) {
          var b, _j, _len;

          for (_j = 0, _len = ball_buttons.length; _j < _len; _j++) {
            b = ball_buttons[_j];
            b.setSelected(false);
          }
          data.target.setSelected(true);
          return _this.ball_type = i;
        };
        button_box.x = Math.round(x - button_box.width / 2);
        button_box.y = Math.round(y - button_box.height / 2);
        ball_buttons.push(button_box);
        return button_box;
      };
      _lockText = function(x, y, size, text, tx, ty) {
        var box, locked_box;

        if (tx == null) {
          tx = 5;
        }
        if (ty == null) {
          ty = 5;
        }
        size = (size + padding) * 2;
        rt = new PIXI.RenderTexture(size + 1, size + 1);
        c = new PIXI.DisplayObjectContainer();
        g = new PIXI.Graphics();
        g.lineStyle(1, 0xFFFFFF);
        g.drawRect(0, 0, size, size);
        c.addChild(g);
        style = {
          font: "9px Arial",
          fill: "#FFFFFF",
          align: 'left',
          wordWrap: true,
          wordWrapWidth: size - tx
        };
        t = new PIXI.Text(text, style);
        t.position.x = tx;
        t.position.y = ty;
        c.addChild(t);
        rt.render(c);
        box = rt;
        locked_box = new PIXI.Sprite(box);
        locked_box.x = Math.round(x - locked_box.width / 2);
        locked_box.y = Math.round(y - locked_box.height / 2);
        return locked_box;
      };
      x = cx / 4;
      y = cy * 1.4;
      size = settings.BALL.SIZE;
      this._cir = _polyButton(x, y, size, 0);
      x += (size + padding) * 2 + margin;
      this._oct = _polyButton(x, y, size, 8);
      this._oct_lock = _lockText(x, y, size, "Best >= 8 Normal AI");
      x += (size + padding) * 2 + margin;
      this._hep = _polyButton(x, y, size, 7);
      this._hep_lock = _lockText(x, y, size, "Complete 7 rounds against AI ");
      x += (size + padding) * 2 + margin;
      this._hex = _polyButton(x, y, size, 6);
      this._hex_lock = _lockText(x, y, size, "Win 6 rounds Normal AI ");
      x = cx / 4;
      y += (size + padding) * 2 + margin;
      this._pen = _polyButton(x, y, size, 5);
      this._pen_lock = _lockText(x, y, size, "Best >= 50 rounds Normal AI ");
      x += (size + padding) * 2 + margin;
      this._sqr = _polyButton(x, y, size, 4);
      this._sqr_lock = _lockText(x, y, size, " ");
      x += (size + padding) * 2 + margin;
      this._tri = _polyButton(x, y, size, 3);
      this._tri_lock = _lockText(x, y, size, "Best >= 30 Normal AI ", 2);
      this._cir.setSelected(true);
      this.world = new b2Dynamics.b2World(new b2Vec2(0, 0), doSleep = false);
      if (settings.DEBUG_DRAW) {
        debug_drawer = new DebugDraw();
        debug_drawer.SetSprite(this.hud_graphics);
        debug_drawer.SetDrawScale(1);
        debug_drawer.SetAlpha(1);
        debug_drawer.SetFillAlpha(1);
        debug_drawer.SetLineThickness(1.0);
        debug_drawer.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit | b2DebugDraw.e_centerOfMassBit | b2DebugDraw.e_controllerBit | b2DebugDraw.e_pairBit | b2DebugDraw.e_aabbBit);
        this.world.SetDebugDraw(debug_drawer);
      }
      b2_w = settings.WIDTH / settings.PPM;
      b2_h = 1;
      offset = b2_h / 2;
      b2_x = b2_w / 2;
      b2_y = -offset;
      bodyDef = new b2Dynamics.b2BodyDef();
      bodyDef.type = b2Dynamics.b2Body.b2_staticBody;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef = new b2Dynamics.b2FixtureDef();
      fixDef.density = 1.0;
      fixDef.friction = 0.5;
      fixDef.restitution = 0.2;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.top_boundary = this.world.CreateBody(bodyDef);
      fix = this.top_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      bodyDef.position.x = b2_x;
      bodyDef.position.y = settings.HEIGHT / settings.PPM + offset;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.bottom_boundary = this.world.CreateBody(bodyDef);
      fix = this.bottom_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      b2_w = b2_h;
      b2_h = settings.HEIGHT / settings.PPM;
      b2_x = -offset;
      b2_y = b2_h / 2;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.left_boundary = this.world.CreateBody(bodyDef);
      fix = this.left_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      b2_x = settings.WIDTH / settings.PPM + offset;
      bodyDef.position.x = b2_x;
      bodyDef.position.y = b2_y;
      fixDef.shape = new b2Shapes.b2PolygonShape();
      fixDef.shape.SetAsBox(b2_w / 2, b2_h / 2);
      this.right_boundary = this.world.CreateBody(bodyDef);
      fix = this.right_boundary.CreateFixture(fixDef);
      f = fix.GetFilterData();
      f.categoryBits = settings.COLLISION_CATEGORY.BOUNDARY;
      fix.SetFilterData(f);
      this._normal_ai = new NormalAI(this);
      this._hard_ai = new HardAI(this);
      g = new PIXI.Graphics();
      g.lineStyle(2, 0xFFFFFF);
      g.drawCircle(0, 0, settings.BALL.SIZE);
      g.moveTo(0, 0);
      g.lineTo(settings.BALL.SIZE, 0);
      t = g.generateTexture();
      sprite = new PIXI.Sprite(t);
      sprite.anchor.x = 0.5;
      sprite.anchor.y = 0.5;
      fix_def = new b2Dynamics.b2FixtureDef();
      fix_def.density = 0.1;
      fix_def.friction = 0.5;
      fix_def.restitution = 1;
      b2_radius = settings.BALL.SIZE / settings.PPM;
      fix_def.shape = new b2Shapes.b2CircleShape(b2_radius);
      this.balls.push(new Ball(this, sprite, fix_def));
      this.balls.push(this._makePolygonBall(8));
      this.balls.push(this._makePolygonBall(7));
      this.balls.push(this._makePolygonBall(6));
      this.balls.push(this._makePolygonBall(5));
      this.balls.push(this._makePolygonBall(4));
      this.balls.push(this._makePolygonBall(3));
      this.gotoMenu();
    }

    Game.prototype._makePolygonBall = function(sides) {
      var b2_size, fix_def, g, poly, sprite, t;

      b2_size = settings.BALL.SIZE / settings.PPM;
      poly = this._getPolygon(sides, b2_size);
      g = new PIXI.Graphics();
      this._drawPolygon(poly, g);
      t = g.generateTexture();
      sprite = new PIXI.Sprite(t);
      sprite.anchor.x = 0.5;
      sprite.anchor.y = 0.5;
      fix_def = new b2Dynamics.b2FixtureDef();
      fix_def.density = 0.1;
      fix_def.friction = 0.5;
      fix_def.restitution = 1;
      fix_def.shape = new b2Shapes.b2PolygonShape.AsArray(poly, sides);
      return new Ball(this, sprite, fix_def);
    };

    Game.prototype._getPolygon = function(sides, radius) {
      var TAU, angle, step_size, v, x, y;

      TAU = 2 * Math.PI;
      step_size = TAU / sides;
      v = [];
      angle = 0;
      while (angle < TAU) {
        x = radius * Math.cos(angle);
        y = radius * Math.sin(angle);
        v.push({
          x: x,
          y: y
        });
        angle += step_size;
      }
      return v;
    };

    Game.prototype._drawPolygon = function(poly, g, x, y, color) {
      var v, v0, _i, _len, _ref;

      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (color == null) {
        color = 0xFFFFFF;
      }
      g.lineStyle(2, color);
      v0 = poly[0];
      g.moveTo(v0.x * settings.PPM + x, v0.y * settings.PPM + y);
      _ref = poly.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        g.lineTo(v.x * settings.PPM + x, v.y * settings.PPM + y);
      }
      g.lineTo(v0.x * settings.PPM + x, v0.y * settings.PPM + y);
      g.moveTo(x, y);
      return g.lineTo(poly[0].x * settings.PPM + x, poly[0].y * settings.PPM + y);
    };

    Game.prototype.update = function() {
      var decimal, dt, new_time, t, time;

      t = (new Date()).getTime();
      dt = t - this._loop_time;
      this._loop_time = t;
      if (dt < 10000) {
        this._start_time -= dt / 1000;
        if (this._start_time > 0) {
          this.hud_stage.alpha = 1 - (this._start_time / this._fade_time);
          this.game_stage.alpha = 1 - (this._start_time / this._fade_time);
        }
      }
      if (this.state === this.states.COUNT_DOWN) {
        new_time = this._count_down - dt / 1000;
        if ((Math.ceil(new_time) < Math.ceil(this._count_down) || this._count_down === 3) && new_time > 0) {
          this._playSound(settings.SOUNDS.START_TIMER.ID);
        }
        this._count_down = new_time;
        if (this._count_down <= 0) {
          this._playSound(settings.SOUNDS.START_BUZZER.ID);
          this.state = this.states.GAME;
          this.hud_stage.removeChild(this.countdown_text);
        }
        this.countdown_text.setText("" + Math.ceil(this._count_down));
      } else if (this.state === this.states.GAME) {
        new_time = this.time - dt / 1000;
        time = Math.ceil(new_time);
        t = "" + time;
        if (t.length === 1) {
          t = "00" + t;
        } else if (t.length === 2) {
          t = "0" + t;
        }
        this.time_text.setText(t);
        if (new_time <= 10) {
          if ((Math.ceil(new_time) < Math.ceil(this.time) || this.time === 10) && new_time > 0) {
            this._playSound(settings.SOUNDS.END_TIMER.ID);
          }
          if (new_time <= 0) {
            this._playSound(settings.SOUNDS.END_BUZZER.ID);
          }
          decimal = new_time - Math.floor(new_time);
          this.time_text.scale.x = decimal + 0.4;
          this.time_text.scale.y = decimal + 0.4;
        }
        this.time = new_time;
        if (this.time <= 0) {
          this.endGame();
          return;
        }
        this.left_paddle.update();
        if (this._player2_type === "normal ai") {
          this._normal_ai.update();
        }
        if (this._player2_type === "hard ai") {
          this._hard_ai.update();
        }
        this.right_paddle.update();
        this.ball.update();
        this.world.Step(settings.BOX2D_TIME_STEP, settings.BOX2D_VI, settings.BOX2D_PI);
        this.world.ClearForces();
        this._checkContacts();
      }
      if (this._score_counter > 0) {
        this._score_counter--;
        this.score_grad.alpha = this._score_counter / this.GRAD_TIME;
        if (this._score_counter <= 0) {
          return this.hud_stage.removeChild(this.score_grad);
        }
      }
    };

    Game.prototype.clear = function() {
      return this.hud_graphics.clear();
    };

    Game.prototype.draw = function() {
      if (this.state === this.states.GAME || this.state === this.states.COUNT_DOWN) {
        this.left_paddle.draw();
        this.right_paddle.draw();
        this.ball.draw();
        if (settings.DEBUG_DRAW) {
          return this.world.DrawDebugData();
        }
      }
    };

    Game.prototype.scoreRight = function() {
      this.right_score++;
      this.right_score_text.setText("" + this.right_score);
      this.score_grad.scale.x = 1;
      this.score_grad.position.x = 0;
      this.hud_stage.addChild(this.score_grad);
      return this._score_counter = this.GRAD_TIME;
    };

    Game.prototype.scoreLeft = function() {
      this.left_score++;
      this.left_score_text.setText("" + this.left_score);
      this.score_grad.scale.x = -1;
      this.score_grad.position.x = settings.WIDTH;
      this.hud_stage.addChild(this.score_grad);
      return this._score_counter = this.GRAD_TIME;
    };

    Game.prototype.startGame = function() {
      var center, style, t, vel, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;

      this.state = this.states.COUNT_DOWN;
      this._count_down = 3;
      this.hud_stage.removeChild(this.begin_text);
      this.hud_stage.removeChild(this.title_text);
      this.hud_stage.removeChild(this.player1_text);
      this.hud_stage.removeChild(this.player2_text);
      this.hud_stage.removeChild(this.controls1);
      this.hud_stage.removeChild(this.swap_box);
      this.hud_stage.removeChild(this.h_stat_text);
      this.hud_stage.removeChild(this.h_wins_text);
      this.hud_stage.removeChild(this.h_losses_text);
      this.hud_stage.removeChild(this.h_ties_text);
      this.hud_stage.removeChild(this.h_best_text);
      this.hud_stage.removeChild(this.h_total1_text);
      this.hud_stage.removeChild(this.nai_stat_text);
      this.hud_stage.removeChild(this.nai_wins_text);
      this.hud_stage.removeChild(this.nai_losses_text);
      this.hud_stage.removeChild(this.nai_ties_text);
      this.hud_stage.removeChild(this.nai_best_text);
      this.hud_stage.removeChild(this.nai_total1_text);
      this.hud_stage.removeChild(this.hai_stat_text);
      this.hud_stage.removeChild(this.hai_wins_text);
      this.hud_stage.removeChild(this.hai_losses_text);
      this.hud_stage.removeChild(this.hai_ties_text);
      this.hud_stage.removeChild(this.hai_best_text);
      this.hud_stage.removeChild(this.hai_total1_text);
      if (_ref = this.controls2, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        this.hud_stage.removeChild(this.controls2);
      }
      if (_ref1 = this.human_box, __indexOf.call(this.hud_stage.children, _ref1) >= 0) {
        this.hud_stage.removeChild(this.human_box);
      }
      if (_ref2 = this.ai_norm_box, __indexOf.call(this.hud_stage.children, _ref2) >= 0) {
        this.hud_stage.removeChild(this.ai_norm_box);
      }
      if (_ref3 = this.ai_hard_box, __indexOf.call(this.hud_stage.children, _ref3) >= 0) {
        this.hud_stage.removeChild(this.ai_hard_box);
      }
      if (_ref4 = this.sfx_box, __indexOf.call(this.hud_stage.children, _ref4) >= 0) {
        this.hud_stage.removeChild(this.sfx_box);
      }
      this.hud_stage.removeChild(this._cir);
      if (_ref5 = this._oct, __indexOf.call(this.hud_stage.children, _ref5) >= 0) {
        this.hud_stage.removeChild(this._oct);
      }
      if (_ref6 = this._oct_lock, __indexOf.call(this.hud_stage.children, _ref6) >= 0) {
        this.hud_stage.removeChild(this._oct_lock);
      }
      if (_ref7 = this._hep, __indexOf.call(this.hud_stage.children, _ref7) >= 0) {
        this.hud_stage.removeChild(this._hep);
      }
      if (_ref8 = this._hep_lock, __indexOf.call(this.hud_stage.children, _ref8) >= 0) {
        this.hud_stage.removeChild(this._hep_lock);
      }
      if (_ref9 = this._hex, __indexOf.call(this.hud_stage.children, _ref9) >= 0) {
        this.hud_stage.removeChild(this._hex);
      }
      if (_ref10 = this._hex_lock, __indexOf.call(this.hud_stage.children, _ref10) >= 0) {
        this.hud_stage.removeChild(this._hex_lock);
      }
      if (_ref11 = this._pen, __indexOf.call(this.hud_stage.children, _ref11) >= 0) {
        this.hud_stage.removeChild(this._pen);
      }
      if (_ref12 = this._pen_lock, __indexOf.call(this.hud_stage.children, _ref12) >= 0) {
        this.hud_stage.removeChild(this._pen_lock);
      }
      if (_ref13 = this._sqr, __indexOf.call(this.hud_stage.children, _ref13) >= 0) {
        this.hud_stage.removeChild(this._sqr);
      }
      if (_ref14 = this._sqr_lock, __indexOf.call(this.hud_stage.children, _ref14) >= 0) {
        this.hud_stage.removeChild(this._sqr_lock);
      }
      if (_ref15 = this._tri, __indexOf.call(this.hud_stage.children, _ref15) >= 0) {
        this.hud_stage.removeChild(this._tri);
      }
      if (_ref16 = this._tri_lock, __indexOf.call(this.hud_stage.children, _ref16) >= 0) {
        this.hud_stage.removeChild(this._tri_lock);
      }
      this.hud_stage.addChild(this.quit_text);
      this.hud_stage.addChild(this.countdown_text);
      this.left_paddle = new Paddle(this, settings.PADDLE.X);
      this.right_paddle = new Paddle(this, settings.WIDTH - settings.PADDLE.X);
      center = {
        x: settings.WIDTH / 2,
        y: settings.HEIGHT / 2
      };
      vel = {
        x: -50,
        y: 0
      };
      this.ball = this.balls[this.ball_type];
      this.ball.init(center, vel);
      this.time = this.time_limit;
      this.left_score = 0;
      this.right_score = 0;
      this._can_score_l = true;
      this._can_score_r = true;
      t = "" + Math.ceil(this.time);
      if (t.length === 1) {
        t = "00" + t;
      } else if (t.length === 2) {
        t = "0" + t;
      }
      this.time_text.setText(t);
      style = {
        font: "" + this.TIME_TEXT_SIZE + "px Arial",
        fill: "#FFFFFF"
      };
      this.time_text.setStyle(style);
      this.time_text.position.x = settings.WIDTH / 2;
      this.time_text.scale.x = 0.5;
      this.time_text.scale.y = 0.5;
      this.left_score_text.setText("" + this.left_score);
      this.right_score_text.setText("" + this.right_score);
      this.hud_stage.addChild(this.time_text);
      this.hud_stage.addChild(this.left_score_text);
      this.hud_stage.addChild(this.right_score_text);
      return this._start_time = this._fade_time;
    };

    Game.prototype.endGame = function(quit) {
      var best, key, _ref;

      if (quit == null) {
        quit = false;
      }
      this.state = this.states.END;
      this.hud_stage.removeChild(this.quit_text);
      if (_ref = this.countdown_text, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        this.hud_stage.removeChild(this.countdown_text);
      }
      this.hud_stage.addChild(this.return_text);
      key = this._player2_type;
      if (quit) {
        this.victor_text.setText("  No one wins!");
        key += " quits";
        ga('set', 'metric4', 1);
      } else if (this.left_score > this.right_score) {
        this.victor_text.setText("Player 1 Wins!");
        key += " wins";
        ga('set', 'metric1', 1);
      } else if (this.left_score < this.right_score) {
        this.victor_text.setText("Player 2 Wins!");
        key += " losses";
        ga('set', 'metric2', 1);
      } else {
        this.victor_text.setText("Player 3 Wins?!");
        key += " ties";
        ga('set', 'metric3', 1);
      }
      this._incSaveItem(key);
      if (!quit) {
        key = this._player2_type + " total 1";
        this._incSaveItem(key, this.left_score);
        key = this._player2_type + " total 2";
        this._incSaveItem(key, this.right_score);
        key = this._player2_type + " best";
        best = this._getSaveItemInt(key);
        if (this.left_score > best) {
          this._setSaveItem(key, this.left_score);
        }
      }
      this.hud_stage.addChild(this.victor_text);
      this.left_paddle.destroy();
      this.right_paddle.destroy();
      return this.ball.destroy();
    };

    Game.prototype.gotoMenu = function() {
      var l, t, w, _ref, _ref1, _ref2, _ref3, _ref4;

      this.state = this.states.MENU;
      this.hud_stage.addChild(this.begin_text);
      this.hud_stage.addChild(this.title_text);
      this.hud_stage.addChild(this.player1_text);
      this.hud_stage.addChild(this.player2_text);
      this.hud_stage.addChild(this.controls1);
      if (this._player2_type === "human") {
        this.hud_stage.addChild(this.controls2);
      }
      this.hud_stage.addChild(this.swap_box);
      this.hud_stage.addChild(this.human_box);
      this.hud_stage.addChild(this.ai_norm_box);
      this.hud_stage.addChild(this.ai_hard_box);
      this.hud_stage.addChild(this.sfx_box);
      this.hud_stage.addChild(this.h_stat_text);
      w = this._getSaveItemInt("human wins");
      this.h_wins_text.setText("Wins: " + w);
      this.hud_stage.addChild(this.h_wins_text);
      l = this._getSaveItemInt("human losses");
      this.h_losses_text.setText("Losses: " + l);
      this.hud_stage.addChild(this.h_losses_text);
      t = this._getSaveItemInt("human ties");
      this.h_ties_text.setText("Ties: " + t);
      this.hud_stage.addChild(this.h_ties_text);
      t = this._getSaveItemInt("human best");
      this.h_best_text.setText("Best: " + t);
      this.hud_stage.addChild(this.h_best_text);
      t = this._getSaveItemInt("human total 1");
      this.h_total1_text.setText("Total: " + t);
      this.hud_stage.addChild(this.h_total1_text);
      this.hud_stage.addChild(this.nai_stat_text);
      w = this._getSaveItemInt("normal ai wins");
      this.nai_wins_text.setText("Wins: " + w);
      this.hud_stage.addChild(this.nai_wins_text);
      l = this._getSaveItemInt("normal ai losses");
      this.nai_losses_text.setText("Losses: " + l);
      this.hud_stage.addChild(this.nai_losses_text);
      t = this._getSaveItemInt("normal ai ties");
      this.nai_ties_text.setText("Ties: " + t);
      this.hud_stage.addChild(this.nai_ties_text);
      t = this._getSaveItemInt("normal ai best");
      this.nai_best_text.setText("Best: " + t);
      this.hud_stage.addChild(this.nai_best_text);
      t = this._getSaveItemInt("normal ai total 1");
      this.nai_total1_text.setText("Total: " + t);
      this.hud_stage.addChild(this.nai_total1_text);
      this.hud_stage.addChild(this.hai_stat_text);
      w = this._getSaveItemInt("hard ai wins");
      this.hai_wins_text.setText("Wins: " + w);
      this.hud_stage.addChild(this.hai_wins_text);
      l = this._getSaveItemInt("hard ai losses");
      this.hai_losses_text.setText("Losses: " + l);
      this.hud_stage.addChild(this.hai_losses_text);
      t = this._getSaveItemInt("hard ai ties");
      this.hai_ties_text.setText("Ties: " + t);
      this.hud_stage.addChild(this.hai_ties_text);
      t = this._getSaveItemInt("hard ai best");
      this.hai_best_text.setText("Best: " + t);
      this.hud_stage.addChild(this.hai_best_text);
      t = this._getSaveItemInt("hard ai total 1");
      this.hai_total1_text.setText("Total: " + t);
      this.hud_stage.addChild(this.hai_total1_text);
      if (_ref = this.return_text, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        this.hud_stage.removeChild(this.return_text);
      }
      if (_ref1 = this.time_text, __indexOf.call(this.hud_stage.children, _ref1) >= 0) {
        this.hud_stage.removeChild(this.time_text);
      }
      if (_ref2 = this.left_score_text, __indexOf.call(this.hud_stage.children, _ref2) >= 0) {
        this.hud_stage.removeChild(this.left_score_text);
      }
      if (_ref3 = this.right_score_text, __indexOf.call(this.hud_stage.children, _ref3) >= 0) {
        this.hud_stage.removeChild(this.right_score_text);
      }
      if (_ref4 = this.victor_text, __indexOf.call(this.hud_stage.children, _ref4) >= 0) {
        this.hud_stage.removeChild(this.victor_text);
      }
      this.hud_stage.addChild(this._cir);
      if (this._getSaveItemInt('oct') === 1) {
        this.hud_stage.addChild(this._oct);
      } else {
        this.hud_stage.addChild(this._oct_lock);
      }
      if (this._getSaveItemInt('hep') === 1) {
        this.hud_stage.addChild(this._hep);
      } else {
        this.hud_stage.addChild(this._hep_lock);
      }
      if (this._getSaveItemInt('hex') === 1) {
        this.hud_stage.addChild(this._hex);
      } else {
        this.hud_stage.addChild(this._hex_lock);
      }
      if (this._getSaveItemInt('pen') === 1) {
        this.hud_stage.addChild(this._pen);
      } else {
        this.hud_stage.addChild(this._pen_lock);
      }
      if (this._getSaveItemInt('sqr') === 1) {
        this.hud_stage.addChild(this._sqr);
      } else {
        this.hud_stage.addChild(this._sqr_lock);
      }
      if (this._getSaveItemInt('tri') === 1) {
        this.hud_stage.addChild(this._tri);
      } else {
        this.hud_stage.addChild(this._tri_lock);
      }
      return this._start_time = this._fade_time;
    };

    Game.prototype.onKeyDown = function(key_code) {
      var bindings;

      bindings = settings.BINDINGS;
      if (this.state === this.states.GAME) {
        switch (key_code) {
          case bindings.P1_UP:
            if (this._wasd_1) {
              this.left_paddle.startUp();
            } else if (this._player2_type === "human") {
              this.right_paddle.startUp();
            }
            break;
          case bindings.P1_DOWN:
            if (this._wasd_1) {
              this.left_paddle.startDown();
            } else if (this._player2_type === "human") {
              this.right_paddle.startDown();
            }
            break;
          case bindings.P1_LEFT:
            if (this._wasd_1) {
              this.left_paddle.startLeft();
            } else if (this._player2_type === "human") {
              this.right_paddle.startLeft();
            }
            break;
          case bindings.P1_RIGHT:
            if (this._wasd_1) {
              this.left_paddle.startRight();
            } else if (this._player2_type === "human") {
              this.right_paddle.startRight();
            }
            break;
          case bindings.P2_UP:
            if (this._wasd_1 && this._player2_type === "human") {
              this.right_paddle.startUp();
            } else {
              this.left_paddle.startUp();
            }
            break;
          case bindings.P2_DOWN:
            if (this._wasd_1 && this._player2_type === "human") {
              this.right_paddle.startDown();
            } else {
              this.left_paddle.startDown();
            }
            break;
          case bindings.P2_LEFT:
            if (this._wasd_1 && this._player2_type === "human") {
              this.right_paddle.startLeft();
            } else {
              this.left_paddle.startLeft();
            }
            break;
          case bindings.P2_RIGHT:
            if (this._wasd_1 && this._player2_type === "human") {
              this.right_paddle.startRight();
            } else {
              this.left_paddle.startRight();
            }
        }
      }
      if (key_code === bindings.START) {
        switch (this.state) {
          case this.states.MENU:
            this.startGame();
            break;
          case this.states.END:
            this.gotoMenu();
        }
      }
      if (key_code === bindings.END && (this.state === this.states.GAME || this.state === this.states.COUNT_DOWN)) {
        return this.endGame(true);
      }
    };

    Game.prototype.onKeyUp = function(key_code) {
      var bindings;

      if (this.state !== this.states.GAME) {
        return;
      }
      bindings = settings.BINDINGS;
      switch (key_code) {
        case bindings.P1_UP:
          if (this._wasd_1) {
            return this.left_paddle.endUp();
          } else if (this._player2_type === "human") {
            return this.right_paddle.endUp();
          }
          break;
        case bindings.P1_DOWN:
          if (this._wasd_1) {
            return this.left_paddle.endDown();
          } else if (this._player2_type === "human") {
            return this.right_paddle.endDown();
          }
          break;
        case bindings.P1_LEFT:
          if (this._wasd_1) {
            return this.left_paddle.endLeft();
          } else if (this._player2_type === "human") {
            return this.right_paddle.endLeft();
          }
          break;
        case bindings.P1_RIGHT:
          if (this._wasd_1) {
            return this.left_paddle.endRight();
          } else if (this._player2_type === "human") {
            return this.right_paddle.endRight();
          }
          break;
        case bindings.P2_UP:
          if (this._wasd_1 && this._player2_type === "human") {
            return this.right_paddle.endUp();
          } else {
            return this.left_paddle.endUp();
          }
          break;
        case bindings.P2_DOWN:
          if (this._wasd_1 && this._player2_type === "human") {
            return this.right_paddle.endDown();
          } else {
            return this.left_paddle.endDown();
          }
          break;
        case bindings.P2_LEFT:
          if (this._wasd_1 && this._player2_type === "human") {
            return this.right_paddle.endLeft();
          } else {
            return this.left_paddle.endLeft();
          }
          break;
        case bindings.P2_RIGHT:
          if (this._wasd_1 && this._player2_type === "human") {
            return this.right_paddle.endRight();
          } else {
            return this.left_paddle.endRight();
          }
      }
    };

    Game.prototype.onMouseDown = function(button, screen_pos) {};

    Game.prototype.onMouseUp = function(button, screen_pos) {};

    Game.prototype.onMouseMove = function(screen_pos) {};

    Game.prototype.onMouseWheel = function(delta) {};

    Game.prototype._onSelectHuman = function() {
      this._player2_type = "human";
      this.hud_stage.addChild(this.controls2);
      return ga('set', 'dimension1', "Human");
    };

    Game.prototype._onSelectNormAI = function() {
      var _ref;

      this._player2_type = "normal ai";
      if (_ref = this.controls2, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        this.hud_stage.removeChild(this.controls2);
      }
      return ga('set', 'dimension1', "Normal AI");
    };

    Game.prototype._onSelectHardAI = function() {
      var _ref;

      this._player2_type = "hard ai";
      if (_ref = this.controls2, __indexOf.call(this.hud_stage.children, _ref) >= 0) {
        this.hud_stage.removeChild(this.controls2);
      }
      return ga('set', 'dimension1', "Hard AI");
    };

    Game.prototype._checkContacts = function() {
      var ball_pos, bodyA, bodyB, contact, paddle_pos, _results;

      contact = this.world.GetContactList();
      _results = [];
      while (contact) {
        if (contact.IsTouching()) {
          bodyA = contact.GetFixtureA().GetBody();
          bodyB = contact.GetFixtureB().GetBody();
          if (bodyA === this.ball.body || bodyB === this.ball.body) {
            if (this._can_score_r && (bodyA === this.left_boundary || bodyB === this.left_boundary)) {
              this._playSound(settings.SOUNDS.SCORE.ID);
              this.scoreRight();
              this._can_score_r = false;
              this._can_score_l = true;
            } else if (this._can_score_l && (bodyA === this.right_boundary || bodyB === this.right_boundary)) {
              this._playSound(settings.SOUNDS.SCORE.ID);
              this.scoreLeft();
              this._can_score_l = false;
              this._can_score_r = true;
            } else if (bodyA === this.left_paddle.paddle_body || bodyB === this.left_paddle.paddle_body) {
              ball_pos = this.ball.position();
              paddle_pos = this.left_paddle.position();
              if (ball_pos.x > paddle_pos.x) {
                this._playSound(settings.SOUNDS.PADDLE_CONTACT.ID);
              }
              this._can_score_l = true;
            } else if (bodyA === this.right_paddle.paddle_body || bodyB === this.right_paddle.paddle_body) {
              ball_pos = this.ball.position();
              paddle_pos = this.right_paddle.position();
              if (ball_pos.x < paddle_pos.x) {
                this._playSound(settings.SOUNDS.PADDLE_CONTACT.ID);
              }
              this._can_score_r = true;
            }
          }
        }
        _results.push(contact = contact.GetNext());
      }
      return _results;
    };

    Game.prototype._playSound = function(id) {
      if (this.play_sfx) {
        return createjs.Sound.play(id);
      }
    };

    Game.prototype._incSaveItem = function(key, amount) {
      var prev;

      if (amount == null) {
        amount = 1;
      }
      prev = localStorage[key];
      if (!prev) {
        prev = "0";
      }
      return localStorage[key] = parseInt(prev) + amount;
    };

    Game.prototype._setSaveItem = function(key, val) {
      return localStorage[key] = val;
    };

    Game.prototype._getSaveItemInt = function(key) {
      var val;

      val = localStorage[key];
      if (!val) {
        val = "0";
      }
      return parseInt(val);
    };

    Game.prototype._swapControls = function() {
      var c, visible_1, visible_2, x, _ref, _ref1;

      this._wasd_1 = !this._wasd_1;
      x = this.controls1.position.x;
      this.controls1.position.x = this.controls2.position.x;
      this.controls2.position.x = x;
      visible_1 = (_ref = this.controls1, __indexOf.call(this.hud_stage.children, _ref) >= 0);
      visible_2 = (_ref1 = this.controls2, __indexOf.call(this.hud_stage.children, _ref1) >= 0);
      if (!visible_1 && visible_2) {
        this.hud_stage.addChild(this.controls1);
        this.hud_stage.removeChild(this.controls2);
      } else if (visible_1 && !visible_2) {
        this.hud_stage.addChild(this.controls2);
        this.hud_stage.removeChild(this.controls1);
      }
      c = this.controls1;
      this.controls1 = this.controls2;
      return this.controls2 = c;
    };

    return Game;

  })();

  $(function() {
    var DOM_LOADED, count, manifest, sound;

    DOM_LOADED = true;
    if (!createjs.Sound.initializeDefaultPlugins()) {
      console.log("Couldn't load sound");
      return main();
    } else {
      manifest = [];
      for (sound in settings.SOUNDS) {
        manifest.push({
          id: settings.SOUNDS[sound].ID,
          src: settings.SOUNDS[sound].SRC
        });
      }
      count = 0;
      createjs.Sound.addEventListener("fileload", function(event) {
        count++;
        if (count === manifest.length) {
          return main();
        }
      });
      createjs.Sound.setVolume(0.5);
      return createjs.Sound.registerManifest(manifest, settings.AUDIO_PATH);
    }
  });

  W = settings.WIDTH;

  H = settings.HEIGHT;

  main = function() {
    var ball_folder, black, blurHandler, canvas, clear, clickHandler, container, contextMenuHandler, draw, event_catcher, focusHandler, game, game_div, gui, keyDownListener, keyUpListener, main_loop, mouseDownHandler, mouseMoveHandler, mouseOutHandler, mouseUpHandler, mouseWheelHandler, onBeforeUnload, onResize, paddle_folder, queue, renderer, stage, update;

    game_div = $('#game');
    container = $('<div>');
    container.css('margin-right', 'auto');
    container.css('margin-left', 'auto');
    container.css('width', "" + W + "px");
    container.css('height', "" + H + "px");
    game_div.append(container);
    game_div.css('width', "" + W + "px");
    game_div.css('height', "" + H + "px");
    game_div.css('margin', "auto");
    black = 0x000000;
    stage = new PIXI.Stage(black);
    renderer = PIXI.autoDetectRenderer(W, H);
    container.append(renderer.view);
    canvas = $('canvas')[0];
    game = new Game(stage);
    gui = new dat.GUI();
    gui.add(game, 'ball_type', 0, 6).step(1);
    paddle_folder = gui.addFolder('Paddle');
    paddle_folder.add(settings.PADDLE, 'MOVE_FORCE');
    paddle_folder.add(settings.PADDLE, 'MAX_VEL');
    paddle_folder.add(settings.PADDLE, 'ANGLE');
    paddle_folder.add(settings.PADDLE, 'DAMPING_MOVE');
    paddle_folder.add(settings.PADDLE, 'DAMPING_STILL');
    ball_folder = gui.addFolder('Ball');
    ball_folder.add(settings.BALL, 'MIN_X_VEL');
    ball_folder.add(settings.BALL, 'MAX_ANGLE');
    ball_folder.add(settings.BALL, 'MAGNUS_FORCE');
    onResize = function() {
      return log_input("resize");
    };
    keyDownListener = function(e) {
      var _ref;

      log_input("key down:", e.keyCode);
      game.onKeyDown(e.keyCode);
      if (e.keyCode === 32 || (37 <= (_ref = e.keyCode) && _ref <= 40)) {
        return e.preventDefault();
      }
    };
    keyUpListener = function(e) {
      log_input("key up:", e.keyCode);
      return game.onKeyUp(e.keyCode);
    };
    onBeforeUnload = function(e) {
      return log_input("leaving");
    };
    mouseMoveHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      log_input("mouse:", x, y);
      return game.onMouseMove({
        x: x,
        y: y
      });
    };
    clickHandler = function(e) {
      var x, y;

      x = e.layerX;
      y = e.layerY;
      return log_input("click:", x, y);
    };
    contextMenuHandler = function(e) {
      log_input("context menu");
      return false;
    };
    mouseDownHandler = function(e) {
      var x, y;

      log_input("mouse down");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseDown(e.button, {
        x: x,
        y: y
      });
    };
    mouseUpHandler = function(e) {
      var x, y;

      log_input("mouse up");
      x = e.layerX;
      y = e.layerY;
      return game.onMouseUp(e.button, {
        x: x,
        y: y
      });
    };
    mouseOutHandler = function(e) {
      return log_input("mouse out");
    };
    mouseWheelHandler = function(e) {
      var delta;

      delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
      return log_input("mouse wheel: ", delta);
    };
    focusHandler = function(e) {
      return log_input("focus");
    };
    blurHandler = function(e) {
      return log_input("blur");
    };
    event_catcher = canvas;
    window.onresize = onResize;
    document.body.addEventListener('keydown', keyDownListener, false);
    document.body.addEventListener('keyup', keyUpListener, false);
    window.onbeforeunload = onBeforeUnload;
    event_catcher.addEventListener('mousemove', mouseMoveHandler, false);
    event_catcher.addEventListener('click', clickHandler, false);
    event_catcher.oncontextmenu = contextMenuHandler;
    event_catcher.addEventListener('mousedown', mouseDownHandler, false);
    event_catcher.addEventListener('mouseup', mouseUpHandler, false);
    event_catcher.addEventListener('mouseout', mouseOutHandler, false);
    event_catcher.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
    event_catcher.addEventListener('mousewheel', mouseWheelHandler, false);
    event_catcher.addEventListener('focus', focusHandler, false);
    event_catcher.addEventListener('blur', blurHandler, false);
    main_loop = function() {
      update();
      clear();
      draw();
      return queue();
    };
    update = function() {
      return game.update();
    };
    clear = function() {
      return game.clear();
    };
    draw = function() {
      game.draw();
      return renderer.render(stage);
    };
    queue = function() {
      return window.requestAnimationFrame(main_loop);
    };
    return main_loop();
  };

  log_input = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (settings.PRINT_INPUT) {
      return console.log.apply(console, args);
    }
  };

}).call(this);
